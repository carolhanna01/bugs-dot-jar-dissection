{
  "project": "ambari",
  "jira_id": "18271",
  "commit": "1eba77a9",
  "classification": {
    "singleLine": false
  },
  "patch": "diff --git a/ambari-server/src/main/java/org/apache/ambari/server/events/listeners/alerts/AlertReceivedListener.java b/ambari-server/src/main/java/org/apache/ambari/server/events/listeners/alerts/AlertReceivedListener.java\nindex 2dcf1d628b..907e4d8230 100644\n--- a/ambari-server/src/main/java/org/apache/ambari/server/events/listeners/alerts/AlertReceivedListener.java\n+++ b/ambari-server/src/main/java/org/apache/ambari/server/events/listeners/alerts/AlertReceivedListener.java\n@@ -19,6 +19,8 @@ package org.apache.ambari.server.events.listeners.alerts;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.locks.Lock;\n \n import org.apache.ambari.server.AmbariException;\n import org.apache.ambari.server.EagerSingleton;\n@@ -52,6 +54,7 @@ import org.slf4j.LoggerFactory;\n \n import com.google.common.eventbus.AllowConcurrentEvents;\n import com.google.common.eventbus.Subscribe;\n+import com.google.common.util.concurrent.Striped;\n import com.google.inject.Inject;\n import com.google.inject.Provider;\n import com.google.inject.Singleton;\n@@ -100,6 +103,12 @@ public class AlertReceivedListener {\n    */\n   private AlertEventPublisher m_alertEventPublisher;\n \n+  /**\n+   * Used for ensuring that creation of {@link AlertCurrentEntity} instances has fine-grain\n+   * locks to prevent duplicates.\n+   */\n+  private Striped<Lock> creationLocks = Striped.lazyWeakLock(100);\n+\n   /**\n    * Constructor.\n    *\n@@ -129,7 +138,7 @@ public class AlertReceivedListener {\n     // many transactions/commits\n     List<Alert> alerts = event.getAlerts();\n \n-    List<AlertCurrentEntity> toCreate = new ArrayList<>();\n+    // these can be wrapped in their own transaction\n     List<AlertCurrentEntity> toMerge = new ArrayList<>();\n     List<AlertCurrentEntity> toCreateHistoryAndMerge = new ArrayList<>();\n \n@@ -173,20 +182,34 @@ public class AlertReceivedListener {\n       AlertCurrentEntity current;\n       AlertState alertState = alert.getState();\n \n-      if (StringUtils.isBlank(alert.getHostName()) || definition.isHostIgnored()) {\n-        current = m_alertsDao.findCurrentByNameNoHost(clusterId, alert.getName());\n-      } else {\n-        current = m_alertsDao.findCurrentByHostAndName(clusterId, alert.getHostName(),\n-          alert.getName());\n-      }\n+      // attempt to lookup the current alert\n+      current = getCurrentEntity(clusterId, alert, definition);\n \n+      // if it doesn't exist then we must create it, ensuring that two or more\n+      // aren't created from other threads\n       if( null == current ){\n-        // if there is no current alert and the state is skipped, then simple\n+\n+        // if there is no current alert and the state is skipped, then simply\n         // skip over this one as there is nothing to update in the databse\n         if (alertState == AlertState.SKIPPED) {\n           continue;\n         }\n \n+        // create a key out of the cluster/definition name/host (possibly null)\n+        int key = Objects.hash(clusterId, alert.getName(), alert.getHostName());\n+        Lock lock = creationLocks.get(key);\n+        lock.lock();\n+\n+        // attempt to lookup the current alert again to ensure that a previous\n+        // thread didn't already create it\n+        try {\n+          // if it's not null anymore, then there's no work to do here\n+          current = getCurrentEntity(clusterId, alert, definition);\n+          if( null != current ) {\n+            continue;\n+          }\n+\n+          // the current alert is still null, so go through and create it\n           AlertHistoryEntity history = createHistory(clusterId, definition, alert);\n \n           // this new alert must reflect the correct MM state for the\n@@ -208,12 +231,14 @@ public class AlertReceivedListener {\n           // brand new alert instances being received are always HARD\n           current.setFirmness(AlertFirmness.HARD);\n \n-        // store the entity for creation later\n-        toCreate.add(current);\n+          m_alertsDao.create(current);\n \n           // create the event to fire later\n           alertEvents.add(new InitialAlertEvent(clusterId, alert, current));\n-\n+        } finally {\n+          // release the lock for this alert\n+          lock.unlock();\n+        }\n       } else if (alertState == current.getAlertHistory().getAlertState()\n           || alertState == AlertState.SKIPPED) {\n \n@@ -319,7 +344,7 @@ public class AlertReceivedListener {\n \n     // invokes the EntityManager create/merge on various entities in a single\n     // transaction\n-    saveEntities(toCreate, toMerge, toCreateHistoryAndMerge);\n+    saveEntities(toMerge, toCreateHistoryAndMerge);\n \n     // broadcast events\n     for (AlertEvent eventToFire : alertEvents) {\n@@ -342,19 +367,31 @@ public class AlertReceivedListener {\n     }\n   }\n \n+  /**\n+   * Gets the {@link AlertCurrentEntity} which cooresponds to the new alert being received, if any.\n+   *\n+   * @param clusterId the ID of the cluster.\n+   * @param alert the alert being received (not {@code null}).\n+   * @param definition  the {@link AlertDefinitionEntity} for the alert being received (not {@code null}).\n+   * @return  the existing current alert or {@code null} for none.\n+   */\n+  private AlertCurrentEntity getCurrentEntity(long clusterId, Alert alert, AlertDefinitionEntity definition){\n+    if (StringUtils.isBlank(alert.getHostName()) || definition.isHostIgnored()) {\n+      return m_alertsDao.findCurrentByNameNoHost(clusterId, alert.getName());\n+    } else {\n+      return m_alertsDao.findCurrentByHostAndName(clusterId, alert.getHostName(),\n+        alert.getName());\n+    }\n+  }\n+\n   /**\n    * Saves alert and alert history entities in single transaction\n-   * @param toCreate - new alerts, create alert and history\n    * @param toMerge - merge alert only\n    * @param toCreateHistoryAndMerge - create new history, merge alert\n    */\n   @Transactional\n-  void saveEntities(List<AlertCurrentEntity> toCreate, List<AlertCurrentEntity> toMerge,\n+  void saveEntities(List<AlertCurrentEntity> toMerge,\n       List<AlertCurrentEntity> toCreateHistoryAndMerge) {\n-    for (AlertCurrentEntity entity : toCreate) {\n-      m_alertsDao.create(entity);\n-    }\n-\n     for (AlertCurrentEntity entity : toMerge) {\n       m_alertsDao.merge(entity, m_configuration.isAlertCacheEnabled());\n     }\ndiff --git a/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertCurrentEntity.java b/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertCurrentEntity.java\nindex b30b1000cb..651e1a1dea 100644\n--- a/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertCurrentEntity.java\n+++ b/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertCurrentEntity.java\n@@ -17,6 +17,8 @@\n  */\n package org.apache.ambari.server.orm.entities;\n \n+import java.util.Objects;\n+\n import javax.persistence.CascadeType;\n import javax.persistence.Column;\n import javax.persistence.Entity;\n@@ -36,6 +38,7 @@ import javax.persistence.TableGenerator;\n import org.apache.ambari.server.state.AlertFirmness;\n import org.apache.ambari.server.state.AlertState;\n import org.apache.ambari.server.state.MaintenanceState;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n \n /**\n  * The {@link AlertCurrentEntity} class represents the most recently received an\n@@ -331,7 +334,13 @@ public class AlertCurrentEntity {\n   }\n \n   /**\n-   *\n+   * Gets the equality to another alert based on the following criteria:\n+   * <ul>\n+   * <li>{@link #alertId}\n+   * <li>{@link #alertHistory}\n+   * </ul>\n+   * <p/>\n+   * {@inheritDoc}\n    */\n   @Override\n   public boolean equals(Object object) {\n@@ -344,21 +353,30 @@ public class AlertCurrentEntity {\n     }\n \n     AlertCurrentEntity that = (AlertCurrentEntity) object;\n+    EqualsBuilder equalsBuilder = new EqualsBuilder();\n \n-    if (alertId != null ? !alertId.equals(that.alertId) : that.alertId != null) {\n-      return false;\n-    }\n-\n-    return true;\n+    equalsBuilder.append(alertId, that.alertId);\n+    equalsBuilder.append(alertHistory, that.alertHistory);\n+    return equalsBuilder.isEquals();\n   }\n \n   /**\n-   *\n+   * Generates a hash for the current alert based on the following criteria:\n+   * <ul>\n+   * <li>{@link #alertId}\n+   * <li>{@link #alertHistory}\n+   * </ul>\n+   * <p/>\n+   * For new alerts, the associated {@link AlertHistoryEntity} may not be\n+   * persisted yet. This will rely on the\n+   * {@link AlertHistoryEntity#equals(Object)} and\n+   * {@link AlertHistoryEntity#hashCode()} being correct.\n+   * <p/>\n+   * {@inheritDoc}\n    */\n   @Override\n   public int hashCode() {\n-    int result = null != alertId ? alertId.hashCode() : 0;\n-    return result;\n+    return Objects.hash(alertId, alertHistory);\n   }\n \n   /**\ndiff --git a/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertDefinitionEntity.java b/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertDefinitionEntity.java\nindex 638646ca6b..0eebf4b319 100644\n--- a/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertDefinitionEntity.java\n+++ b/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertDefinitionEntity.java\n@@ -20,6 +20,7 @@ package org.apache.ambari.server.orm.entities;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.Objects;\n import java.util.Set;\n \n import javax.persistence.Basic;\n@@ -593,7 +594,17 @@ public class AlertDefinitionEntity {\n   }\n \n   /**\n-   *\n+   * Gets the equality to another historical alert entry based on the following criteria:\n+   * <ul>\n+   * <li>{@link #definitionId}\n+   * <li>{@link #clusterId}\n+   * <li>{@link #definitionName}\n+   * </ul>\n+   * <p/>\n+   * However, since we're guaranteed that {@link #definitionId} is unique among persisted entities, we\n+   * can return the hashCode based on this value if it is set.\n+   * <p/>\n+   * {@inheritDoc}\n    */\n   @Override\n   public boolean equals(Object object) {\n@@ -607,21 +618,31 @@ public class AlertDefinitionEntity {\n \n     AlertDefinitionEntity that = (AlertDefinitionEntity) object;\n \n-    if (definitionId != null ? !definitionId.equals(that.definitionId)\n-      : that.definitionId != null) {\n-      return false;\n+    // use the unique ID if it exists\n+    if( null != definitionId ){\n+      return Objects.equals(definitionId, that.definitionId);\n     }\n \n-    return true;\n+    return Objects.equals(definitionId, that.definitionId) &&\n+        Objects.equals(clusterId, that.clusterId) &&\n+        Objects.equals(definitionName, that.definitionName);\n   }\n \n   /**\n-   *\n+   * Gets a hash to uniquely identify this alert definition. Since we're\n+   * guaranteed that {@link #definitionId} is unique among persisted entities,\n+   * we can return the hashCode based on this value if it is set.\n+   * <p/>\n+   * {@inheritDoc}\n    */\n   @Override\n   public int hashCode() {\n-    int result = null != definitionId ? definitionId.hashCode() : 0;\n-    return result;\n+    // use the unique ID if it exists\n+    if( null != definitionId ){\n+      return definitionId.hashCode();\n+    }\n+\n+    return Objects.hash(definitionId, clusterId, definitionName);\n   }\n \n   /**\ndiff --git a/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertHistoryEntity.java b/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertHistoryEntity.java\nindex 8bc4b99265..958740a142 100644\n--- a/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertHistoryEntity.java\n+++ b/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/AlertHistoryEntity.java\n@@ -17,6 +17,8 @@\n  */\n package org.apache.ambari.server.orm.entities;\n \n+import java.util.Objects;\n+\n import javax.persistence.Column;\n import javax.persistence.Entity;\n import javax.persistence.EnumType;\n@@ -331,7 +333,7 @@ public class AlertHistoryEntity {\n    */\n   public void setAlertDefinition(AlertDefinitionEntity alertDefinition) {\n     this.alertDefinition = alertDefinition;\n-    this.alertDefinitionId = alertDefinition.getDefinitionId();\n+    alertDefinitionId = alertDefinition.getDefinitionId();\n   }\n \n   /**\n@@ -351,7 +353,25 @@ public class AlertHistoryEntity {\n   }\n \n   /**\n-   *\n+   * Gets the equality to another historical alert entry based on the following criteria:\n+   * <ul>\n+   * <li>{@link #alertId}\n+   * <li>{@link #clusterId}\n+   * <li>{@link #alertInstance}\n+   * <li>{@link #alertLabel}\n+   * <li>{@link #alertState}\n+   * <li>{@link #alertText}\n+   * <li>{@link #alertTimestamp}\n+   * <li>{@link #serviceName}\n+   * <li>{@link #componentName}\n+   * <li>{@link #hostName}\n+   * <li>{@link #alertDefinition}\n+   * </ul>\n+   * <p/>\n+   * However, since we're guaranteed that {@link #alertId} is unique among persisted entities, we\n+   * can return the hashCode based on this value if it is set.\n+   * <p/>\n+   * {@inheritDoc}\n    */\n   @Override\n   public boolean equals(Object object) {\n@@ -365,20 +385,43 @@ public class AlertHistoryEntity {\n \n     AlertHistoryEntity that = (AlertHistoryEntity) object;\n \n-    if (alertId != null ? !alertId.equals(that.alertId) : that.alertId != null) {\n-      return false;\n+    // use the unique ID if it exists\n+    if( null != alertId ){\n+      return Objects.equals(alertId, that.alertId);\n     }\n \n-    return true;\n+    return Objects.equals(alertId, that.alertId) &&\n+        Objects.equals(clusterId, that.clusterId) &&\n+        Objects.equals(alertInstance, that.alertInstance) &&\n+        Objects.equals(alertLabel, that.alertLabel) &&\n+        Objects.equals(alertState, that.alertState) &&\n+        Objects.equals(alertText, that.alertText) &&\n+        Objects.equals(alertTimestamp, that.alertTimestamp) &&\n+        Objects.equals(serviceName, that.serviceName) &&\n+        Objects.equals(componentName, that.componentName) &&\n+        Objects.equals(hostName, that.hostName) &&\n+        Objects.equals(alertDefinition, that.alertDefinition);\n   }\n \n   /**\n-   *\n+   * Gets a hash to uniquely identify this historical alert instance. Since historical entries\n+   * have no real uniqueness properties, we need to rely on a combination of the fields of this\n+   * entity.\n+   * <p/>\n+   * However, since we're guaranteed that {@link #alertId} is unique among persisted entities, we\n+   * can return the hashCode based on this value if it is set.\n+   * <p/>\n+   * {@inheritDoc}\n    */\n   @Override\n   public int hashCode() {\n-    int result = null != alertId ? alertId.hashCode() : 0;\n-    return result;\n+    // use the unique ID if it exists\n+    if( null != alertId ){\n+      return alertId.hashCode();\n+    }\n+\n+    return Objects.hash(alertId, clusterId, alertInstance, alertLabel, alertState, alertText,\n+        alertTimestamp, serviceName, componentName, hostName, alertDefinition);\n   }\n \n   /**\n",
  "files": 4,
  "linesAdd": 162,
  "linesRem": 43,
  "failing_tests": [
    "org.apache.ambari.server.orm.entities.AlertCurrentEntityTest.testHashCodeAndEquals",
    "org.apache.ambari.server.orm.entities.AlertDefinitionEntityTest.testHashCodeAndEquals",
    "org.apache.ambari.server.orm.entities.AlertHistoryEntityTest.testHashCodeAndEquals",
    "org.apache.ambari.server.state.alerts.AlertReceivedListenerTest.testMultipleNewAlertEvents"
  ],
  "nb_test": 4614,
  "nb_failure": 4,
  "nb_error": 0,
  "nb_skipped": 34
}