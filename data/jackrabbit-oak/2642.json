{"nb_failure": 1, "nb_error": 0, "failing_tests": ["dispose(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): Merge must fail with CommitFailedException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 043f344..2de0d39 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -459,40 +459,50 @@ public final class DocumentNodeStore\n     }\n \n     public void dispose() {\n-        runBackgroundOperations();\n-        if (!isDisposed.getAndSet(true)) {\n-            synchronized (isDisposed) {\n-                isDisposed.notifyAll();\n-            }\n+        if (isDisposed.getAndSet(true)) {\n+            // only dispose once\n+            return;\n+        }\n+        // notify background threads waiting on isDisposed\n+        synchronized (isDisposed) {\n+            isDisposed.notifyAll();\n+        }\n+        try {\n+            backgroundThread.join();\n+        } catch (InterruptedException e) {\n+            // ignore\n+        }\n+\n+        // do a final round of background operations after\n+        // the background thread stopped\n+        internalRunBackgroundOperations();\n+\n+        if (leaseUpdateThread != null) {\n             try {\n-                backgroundThread.join();\n+                leaseUpdateThread.join();\n             } catch (InterruptedException e) {\n                 // ignore\n             }\n-            if (leaseUpdateThread != null) {\n-                try {\n-                    leaseUpdateThread.join();\n-                } catch (InterruptedException e) {\n-                    // ignore\n-                }\n-            }\n-            if (clusterNodeInfo != null) {\n-                clusterNodeInfo.dispose();\n-            }\n-            store.dispose();\n-            LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n-\n-            if (blobStore instanceof Closeable) {\n-                try {\n-                    ((Closeable) blobStore).close();\n-                } catch (IOException ex) {\n-                    LOG.debug(\"Error closing blob store \" + blobStore, ex);\n-                }\n+        }\n+\n+        // now mark this cluster node as inactive by\n+        // disposing the clusterNodeInfo\n+        if (clusterNodeInfo != null) {\n+            clusterNodeInfo.dispose();\n+        }\n+        store.dispose();\n+\n+        if (blobStore instanceof Closeable) {\n+            try {\n+                ((Closeable) blobStore).close();\n+            } catch (IOException ex) {\n+                LOG.debug(\"Error closing blob store \" + blobStore, ex);\n             }\n         }\n         if (persistentCache != null) {\n             persistentCache.close();\n         }\n+        LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n     }\n \n     Revision setHeadRevision(@Nonnull Revision newHead) {\n@@ -544,6 +554,7 @@ public final class DocumentNodeStore\n             base = headRevision;\n         }\n         backgroundOperationLock.readLock().lock();\n+        checkOpen();\n         boolean success = false;\n         Commit c;\n         try {\n@@ -573,6 +584,7 @@ public final class DocumentNodeStore\n             base = headRevision;\n         }\n         backgroundOperationLock.readLock().lock();\n+        checkOpen();\n         boolean success = false;\n         MergeCommit c;\n         try {\n@@ -1502,48 +1514,49 @@ public final class DocumentNodeStore\n \n     //----------------------< background operations >---------------------------\n \n-    public synchronized void runBackgroundOperations() {\n+    public void runBackgroundOperations() {\n         if (isDisposed.get()) {\n             return;\n         }\n-        if (simpleRevisionCounter != null) {\n-            // only when using timestamp\n-            return;\n-        }\n         try {\n-            long start = clock.getTime();\n-            long time = start;\n-            // clean orphaned branches and collisions\n-            cleanOrphanedBranches();\n-            cleanCollisions();\n-            long cleanTime = clock.getTime() - time;\n-            time = clock.getTime();\n-            // split documents (does not create new revisions)\n-            backgroundSplit();\n-            long splitTime = clock.getTime() - time;\n-            time = clock.getTime();\n-            // write back pending updates to _lastRev\n-            backgroundWrite();\n-            long writeTime = clock.getTime() - time;\n-            time = clock.getTime();\n-            // pull in changes from other cluster nodes\n-            BackgroundReadStats readStats = backgroundRead(true);\n-            long readTime = clock.getTime() - time;\n-            String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n-            if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\n-                // log as info if it took more than 10 seconds\n-                LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n-            } else {\n-                LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n-            }\n+            internalRunBackgroundOperations();\n         } catch (RuntimeException e) {\n             if (isDisposed.get()) {\n+                LOG.warn(\"Background operation failed: \" + e.toString(), e);\n                 return;\n             }\n             throw e;\n         }\n     }\n \n+    private synchronized void internalRunBackgroundOperations() {\n+        long start = clock.getTime();\n+        long time = start;\n+        // clean orphaned branches and collisions\n+        cleanOrphanedBranches();\n+        cleanCollisions();\n+        long cleanTime = clock.getTime() - time;\n+        time = clock.getTime();\n+        // split documents (does not create new revisions)\n+        backgroundSplit();\n+        long splitTime = clock.getTime() - time;\n+        time = clock.getTime();\n+        // write back pending updates to _lastRev\n+        backgroundWrite();\n+        long writeTime = clock.getTime() - time;\n+        time = clock.getTime();\n+        // pull in changes from other cluster nodes\n+        BackgroundReadStats readStats = backgroundRead(true);\n+        long readTime = clock.getTime() - time;\n+        String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n+        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\n+            // log as info if it took more than 10 seconds\n+            LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n+        } else {\n+            LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n+        }\n+    }\n+\n     /**\n      * Renews the cluster lease if necessary.\n      *\n@@ -1771,6 +1784,19 @@ public final class DocumentNodeStore\n \n     //-----------------------------< internal >---------------------------------\n \n+    /**\n+     * Checks if this store is still open and throws an\n+     * {@link IllegalStateException} if it is already disposed (or a dispose\n+     * is in progress).\n+     *\n+     * @throws IllegalStateException if this store is disposed.\n+     */\n+    private void checkOpen() throws IllegalStateException {\n+        if (isDisposed.get()) {\n+            throw new IllegalStateException(\"This DocumentNodeStore is disposed\");\n+        }\n+    }\n+\n     private boolean dispatch(@Nonnull String jsonDiff,\n                              @Nonnull DocumentNodeState node,\n                              @Nonnull DocumentNodeState base,\n", "nb_test": 2004, "nb_skipped": 9, "fix_commit": "36fe017c", "id": "2642"}