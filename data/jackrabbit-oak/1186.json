{
  "files": 3, 
  "singleLine": false, 
  "nb_error": 0, 
  "failing_tests": [
    "resetConflictAddExistingNode(org.apache.jackrabbit.oak.plugins.mongomk.MongoMKResetTest): /foo does not exist", 
    "resetConflictRemoveRemovedNode(org.apache.jackrabbit.oak.plugins.mongomk.MongoMKResetTest): /foo should not exist"
  ], 
  "nb_test": 1443, 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\nindex ac9ee2f..8581ecb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n@@ -28,6 +28,7 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n@@ -50,6 +51,7 @@ import javax.annotation.Nullable;\n import com.google.common.base.Function;\n import com.google.common.cache.Cache;\n import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import org.apache.jackrabbit.mk.api.MicroKernelException;\n import org.apache.jackrabbit.mk.blobs.BlobStore;\n@@ -786,28 +788,57 @@ public final class MongoNodeStore\n         if (b == null) {\n             throw new MicroKernelException(\"Empty branch cannot be reset\");\n         }\n+        if (!b.getCommits().last().equals(branchHead)) {\n+            throw new MicroKernelException(branchHead + \" is not the head \" +\n+                    \"of a branch\");\n+        }\n         if (!b.containsCommit(ancestor)) {\n             throw new MicroKernelException(ancestor + \" is not \" +\n                     \"an ancestor revision of \" + branchHead);\n         }\n-        Revision rev;\n+        if (branchHead.equals(ancestor)) {\n+            // trivial\n+            return branchHead;\n+        }\n         boolean success = false;\n         Commit commit = newCommit(branchHead);\n         try {\n-            // apply reverse diff\n-            getRoot(ancestor).compareAgainstBaseState(getRoot(branchHead),\n-                    new CommitDiff(commit, getBlobSerializer()));\n-            UpdateOp rootOp = commit.getUpdateOperationForNode(\"/\");\n-            // clear collisions\n             Iterator<Revision> it = b.getCommits().tailSet(ancestor).iterator();\n             // first revision is the ancestor (tailSet is inclusive)\n-            // do not clear collision for this revision\n-            it.next();\n+            // do not undo changes for this revision\n+            Revision base = it.next();\n+            Map<String, UpdateOp> operations = new HashMap<String, UpdateOp>();\n             while (it.hasNext()) {\n-                NodeDocument.removeCollision(rootOp, it.next());\n+                Revision reset = it.next();\n+                getRoot(reset).compareAgainstBaseState(getRoot(base),\n+                        new ResetDiff(reset.asTrunkRevision(), operations));\n+                UpdateOp rootOp = operations.get(\"/\");\n+                if (rootOp == null) {\n+                    rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n+                    NodeDocument.setModified(rootOp, commit.getRevision());\n+                    operations.put(\"/\", rootOp);\n+                }\n+                NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n+                NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n+            }\n+            // update root document first\n+            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n+                // clean up in-memory branch data\n+                // first revision is the ancestor (tailSet is inclusive)\n+                List<Revision> revs = Lists.newArrayList(b.getCommits().tailSet(ancestor));\n+                for (Revision r : revs.subList(1, revs.size())) {\n+                    b.removeCommit(r);\n+                }\n+                // successfully updating the root document can be considered\n+                // as success because the changes are not marked as committed\n+                // anymore\n+                success = true;\n+            }\n+            operations.remove(\"/\");\n+            // update remaining documents\n+            for (UpdateOp op : operations.values()) {\n+                store.findAndUpdate(Collection.NODES, op);\n             }\n-            rev = apply(commit);\n-            success = true;\n         } finally {\n             if (!success) {\n                 canceled(commit);\n@@ -815,7 +846,7 @@ public final class MongoNodeStore\n                 done(commit, true, null);\n             }\n         }\n-        return rev;\n+        return ancestor;\n     }\n \n     @Nonnull\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\nindex de0d062..aba6a98 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\n@@ -843,6 +843,11 @@ public class NodeDocument extends Document {\n         checkNotNull(op).unsetMapEntry(REVISIONS, checkNotNull(revision));\n     }\n \n+    public static void removeRevision(@Nonnull UpdateOp op,\n+                                      @Nonnull Revision revision) {\n+        checkNotNull(op).removeMapEntry(REVISIONS, checkNotNull(revision));\n+    }\n+\n     public static void removeCollision(@Nonnull UpdateOp op,\n                                        @Nonnull Revision revision) {\n         checkNotNull(op).removeMapEntry(COLLISIONS, checkNotNull(revision));\n@@ -872,6 +877,11 @@ public class NodeDocument extends Document {\n                 String.valueOf(commitRootDepth));\n     }\n \n+    public static void removeCommitRoot(@Nonnull UpdateOp op,\n+                                        @Nonnull Revision revision) {\n+        checkNotNull(op).removeMapEntry(COMMIT_ROOT, revision);\n+    }\n+\n     public static void setDeleted(@Nonnull UpdateOp op,\n                                   @Nonnull Revision revision,\n                                   boolean deleted) {\n@@ -879,6 +889,11 @@ public class NodeDocument extends Document {\n                 String.valueOf(deleted));\n     }\n \n+    public static void removeDeleted(@Nonnull UpdateOp op,\n+                                     @Nonnull Revision revision) {\n+        checkNotNull(op).removeMapEntry(DELETED, revision);\n+    }\n+\n     //----------------------------< internal >----------------------------------\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ResetDiff.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ResetDiff.java\nnew file mode 100644\nindex 0000000..9559887\n--- /dev/null\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ResetDiff.java\n@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.jackrabbit.oak.plugins.mongomk;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.apache.jackrabbit.oak.api.PropertyState;\n+import org.apache.jackrabbit.oak.commons.PathUtils;\n+import org.apache.jackrabbit.oak.plugins.mongomk.util.Utils;\n+import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;\n+import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;\n+\n+/**\n+ * Implementation of a node state diff, which translates a diff into reset\n+ * operations on a branch.\n+ */\n+class ResetDiff implements NodeStateDiff {\n+\n+    private final Revision revision;\n+    private final String path;\n+    private final Map<String, UpdateOp> operations;\n+    private UpdateOp update;\n+\n+    ResetDiff(@Nonnull Revision revision,\n+              @Nonnull Map<String, UpdateOp> operations) {\n+        this(revision, \"/\", operations);\n+    }\n+\n+    private ResetDiff(@Nonnull Revision revision,\n+                      @Nonnull String path,\n+                      @Nonnull Map<String, UpdateOp> operations) {\n+        this.revision = checkNotNull(revision);\n+        this.path = checkNotNull(path);\n+        this.operations = checkNotNull(operations);\n+    }\n+\n+    @Override\n+    public boolean propertyAdded(PropertyState after) {\n+        getUpdateOp().removeMapEntry(after.getName(), revision);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean propertyChanged(PropertyState before, PropertyState after) {\n+        getUpdateOp().removeMapEntry(after.getName(), revision);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean propertyDeleted(PropertyState before) {\n+        getUpdateOp().removeMapEntry(before.getName(), revision);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean childNodeAdded(String name, NodeState after) {\n+        String p = PathUtils.concat(path, name);\n+        ResetDiff diff = new ResetDiff(revision, p, operations);\n+        UpdateOp op = diff.getUpdateOp();\n+        NodeDocument.removeDeleted(op, revision);\n+        return after.compareAgainstBaseState(EMPTY_NODE, diff);\n+    }\n+\n+    @Override\n+    public boolean childNodeChanged(String name,\n+                                    NodeState before,\n+                                    NodeState after) {\n+        String p = PathUtils.concat(path, name);\n+        return after.compareAgainstBaseState(before,\n+                new ResetDiff(revision, p, operations));\n+    }\n+\n+    @Override\n+    public boolean childNodeDeleted(String name, NodeState before) {\n+        String p = PathUtils.concat(path, name);\n+        ResetDiff diff = new ResetDiff(revision, p, operations);\n+        NodeDocument.removeDeleted(diff.getUpdateOp(), revision);\n+        return MISSING_NODE.compareAgainstBaseState(before, diff);\n+    }\n+\n+    Map<String, UpdateOp> getOperations() {\n+        return operations;\n+    }\n+\n+    private UpdateOp getUpdateOp() {\n+        if (update == null) {\n+            update = operations.get(path);\n+            if (update == null) {\n+                String id = Utils.getIdFromPath(path);\n+                update = new UpdateOp(id, false);\n+                operations.put(path, update);\n+            }\n+            NodeDocument.removeRevision(update, revision);\n+            NodeDocument.removeCommitRoot(update, revision);\n+        }\n+        return update;\n+    }\n+}\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 176, 
  "nb_skipped": 6, 
  "fix_commit": "52372042", 
  "nb_failure": 2, 
  "id": "1186", 
  "linesRem": 12
}