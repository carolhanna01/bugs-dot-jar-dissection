{
  "files": 1, 
  "singleLine": false, 
  "nb_error": 1, 
  "failing_tests": [
    "multiValuesForOrderedIndexShouldNotThrow(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest): Exception thrown when indexing invalid content", 
    "sortQueriesWithStringIgnoredMulti_OrderedProps(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): OakLucene0003: Failed to index the node /test/a"
  ], 
  "nb_test": 459, 
  "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex ea255df..2e60d8d 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -461,6 +461,14 @@ public class LuceneIndexEditor implements IndexEditor, Aggregate.AggregateRoot {\n                                           PropertyState property,\n                                           String pname,\n                                           PropertyDefinition pd) throws CommitFailedException {\n+        // Ignore and warn if property multi-valued as not supported\n+        if (property.getType().isArray()) {\n+            log.warn(\n+                \"Ignoring ordered property {} of type {} for path {} as multivalued ordered property not supported\",\n+                pname, Type.fromTag(property.getType().tag(), true), getPath());\n+            return false;\n+        }\n+\n         int tag = property.getType().tag();\n         int idxDefinedTag = pd.getType();\n         // Try converting type to the defined type in the index definition\n@@ -475,37 +483,35 @@ public class LuceneIndexEditor implements IndexEditor, Aggregate.AggregateRoot {\n \n         String name = FieldNames.createDocValFieldName(pname);\n         boolean fieldAdded = false;\n-        for (int i = 0; i < property.count(); i++) {\n-            Field f = null;\n-            try {\n-                if (tag == Type.LONG.tag()) {\n-                    //TODO Distinguish fields which need to be used for search and for sort\n-                    //If a field is only used for Sort then it can be stored with less precision\n-                    f = new NumericDocValuesField(name, property.getValue(Type.LONG, i));\n-                } else if (tag == Type.DATE.tag()) {\n-                    String date = property.getValue(Type.DATE, i);\n-                    f = new NumericDocValuesField(name, FieldFactory.dateToLong(date));\n-                } else if (tag == Type.DOUBLE.tag()) {\n-                    f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE, i));\n-                } else if (tag == Type.BOOLEAN.tag()) {\n-                    f = new SortedDocValuesField(name,\n-                        new BytesRef(property.getValue(Type.BOOLEAN, i).toString()));\n-                } else if (tag == Type.STRING.tag()) {\n-                    f = new SortedDocValuesField(name,\n-                        new BytesRef(property.getValue(Type.STRING, i)));\n-                }\n+        Field f = null;\n+        try {\n+            if (tag == Type.LONG.tag()) {\n+                //TODO Distinguish fields which need to be used for search and for sort\n+                //If a field is only used for Sort then it can be stored with less precision\n+                f = new NumericDocValuesField(name, property.getValue(Type.LONG));\n+            } else if (tag == Type.DATE.tag()) {\n+                String date = property.getValue(Type.DATE);\n+                f = new NumericDocValuesField(name, FieldFactory.dateToLong(date));\n+            } else if (tag == Type.DOUBLE.tag()) {\n+                f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE));\n+            } else if (tag == Type.BOOLEAN.tag()) {\n+                f = new SortedDocValuesField(name,\n+                    new BytesRef(property.getValue(Type.BOOLEAN).toString()));\n+            } else if (tag == Type.STRING.tag()) {\n+                f = new SortedDocValuesField(name,\n+                    new BytesRef(property.getValue(Type.STRING)));\n+            }\n \n-                if (f != null) {\n-                    fields.add(f);\n-                    fieldAdded = true;\n-                }\n-            } catch (Exception e) {\n-                log.warn(\n-                    \"Ignoring ordered property. Could not convert property {} of type {} to type \" +\n-                        \"{} for path {}\",\n-                    pname, Type.fromTag(property.getType().tag(), false),\n-                    Type.fromTag(tag, false), getPath(), e);\n+            if (f != null) {\n+                fields.add(f);\n+                fieldAdded = true;\n             }\n+        } catch (Exception e) {\n+            log.warn(\n+                \"Ignoring ordered property. Could not convert property {} of type {} to type \" +\n+                    \"{} for path {}\",\n+                pname, Type.fromTag(property.getType().tag(), false),\n+                Type.fromTag(tag, false), getPath(), e);\n         }\n         return fieldAdded;\n     }\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 35, 
  "nb_skipped": 3, 
  "fix_commit": "147515ae", 
  "nb_failure": 1, 
  "id": "3020", 
  "linesRem": 29
}