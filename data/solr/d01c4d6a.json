{
  "project": "solr",
  "jira_id": "6520",
  "commit": "d01c4d6a",
  "classification": {
    "singleLine": false
  },
  "patch": "diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java\nindex 379467b048..2dfacaca1d 100755\n--- a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java\n+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java\n@@ -113,15 +113,21 @@ public class GeoPath extends GeoBaseExtendedShape implements GeoDistanceShape {\n       \n       // General intersection case\n       final PathSegment prevSegment = segments.get(i-1);\n-      if (prevSegment.upperConnectingPlane.isNumericallyIdentical(currentSegment.upperConnectingPlane) &&\n-          prevSegment.lowerConnectingPlane.isNumericallyIdentical(currentSegment.lowerConnectingPlane)) {\n+      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n+      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n+      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n+      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n+      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n+\n+      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n         // The planes are identical.  We don't need a circle at all.  Special constructor...\n         endPoints.add(new SegmentEndpoint(currentSegment.start));\n       } else {\n         endPoints.add(new SegmentEndpoint(currentSegment.start,\n           prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n           prevSegment.URHC, prevSegment.LRHC,\n-          currentSegment.ULHC, currentSegment.LLHC));\n+          currentSegment.ULHC, currentSegment.LLHC,\n+          candidate1, candidate2, candidate3, candidate4));\n       }\n     }\n     // Do final endpoint\n@@ -458,8 +464,9 @@ public class GeoPath extends GeoBaseExtendedShape implements GeoDistanceShape {\n      */\n     public SegmentEndpoint(final GeoPoint point,\n       final SidedPlane prevCutoffPlane, final SidedPlane nextCutoffPlane,\n-      final GeoPoint prevUpperGeoPoint, final GeoPoint prevLowerGeoPoint,\n-      final GeoPoint nextUpperGeoPoint, final GeoPoint nextLowerGeoPoint) {\n+      final GeoPoint notCand2Point, final GeoPoint notCand1Point,\n+      final GeoPoint notCand3Point, final GeoPoint notCand4Point,\n+      final SidedPlane candidate1, final SidedPlane candidate2, final SidedPlane candidate3, final SidedPlane candidate4) {\n       // Note: What we really need is a single plane that goes through all four points.\n       // Since that's not possible in the ellipsoid case (because three points determine a plane, not four), we\n       // need an approximation that at least creates a boundary that has no interruptions.\n@@ -472,38 +479,35 @@ public class GeoPath extends GeoBaseExtendedShape implements GeoDistanceShape {\n       this.point = point;\n       \n       // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n-      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(point, prevUpperGeoPoint, nextUpperGeoPoint, nextLowerGeoPoint);\n-      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(point, nextUpperGeoPoint, nextLowerGeoPoint, prevLowerGeoPoint);\n-      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(point, nextLowerGeoPoint, prevLowerGeoPoint, prevUpperGeoPoint);\n-      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(point, prevLowerGeoPoint, prevUpperGeoPoint, nextUpperGeoPoint);\n+      // (Constructed beforehand because we need them for degeneracy check)\n \n-      final boolean cand1IsOtherWithin = candidate1.isWithin(prevLowerGeoPoint);\n-      final boolean cand2IsOtherWithin = candidate2.isWithin(prevUpperGeoPoint);\n-      final boolean cand3IsOtherWithin = candidate3.isWithin(nextUpperGeoPoint);\n-      final boolean cand4IsOtherWithin = candidate4.isWithin(nextLowerGeoPoint);\n+      final boolean cand1IsOtherWithin = candidate1!=null?candidate1.isWithin(notCand1Point):false;\n+      final boolean cand2IsOtherWithin = candidate2!=null?candidate2.isWithin(notCand2Point):false;\n+      final boolean cand3IsOtherWithin = candidate3!=null?candidate3.isWithin(notCand3Point):false;\n+      final boolean cand4IsOtherWithin = candidate4!=null?candidate4.isWithin(notCand4Point):false;\n       \n       if (cand1IsOtherWithin && cand2IsOtherWithin && cand3IsOtherWithin && cand4IsOtherWithin) {\n         // The only way we should see both within is if all four points are coplanar.  In that case, we default to the simplest treatment.\n         this.circlePlane = candidate1;  // doesn't matter which\n-        this.notablePoints = new GeoPoint[]{prevUpperGeoPoint, nextUpperGeoPoint, prevLowerGeoPoint, nextLowerGeoPoint};\n+        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand1Point, notCand4Point};\n         this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane), new SidedPlane(nextCutoffPlane)};\n       } else if (cand1IsOtherWithin) {\n         // Use candidate1, and DON'T include prevCutoffPlane in the cutoff planes list\n         this.circlePlane = candidate1;\n-        this.notablePoints = new GeoPoint[]{prevUpperGeoPoint, nextUpperGeoPoint, nextLowerGeoPoint};\n+        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand4Point};\n         this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n       } else if (cand2IsOtherWithin) {\n         // Use candidate2\n         this.circlePlane = candidate2;\n-        this.notablePoints = new GeoPoint[]{nextUpperGeoPoint, nextLowerGeoPoint, prevLowerGeoPoint};\n+        this.notablePoints = new GeoPoint[]{notCand3Point, notCand4Point, notCand1Point};\n         this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n       } else if (cand3IsOtherWithin) {\n         this.circlePlane = candidate3;\n-        this.notablePoints = new GeoPoint[]{nextLowerGeoPoint, prevLowerGeoPoint, prevUpperGeoPoint};\n+        this.notablePoints = new GeoPoint[]{notCand4Point, notCand1Point, notCand2Point};\n         this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n       } else if (cand4IsOtherWithin) {\n         this.circlePlane = candidate4;\n-        this.notablePoints = new GeoPoint[]{prevLowerGeoPoint, prevUpperGeoPoint, nextUpperGeoPoint};\n+        this.notablePoints = new GeoPoint[]{notCand1Point, notCand2Point, notCand3Point};\n         this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n       } else {\n         // dunno what happened\n",
  "files": 1,
  "linesAdd": 22,
  "linesRem": 18,
  "failing_tests": [],
  "nb_test": 0,
  "nb_failure": 0,
  "nb_error": 0,
  "nb_skipped": 0
}