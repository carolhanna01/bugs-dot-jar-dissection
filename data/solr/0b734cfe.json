{
  "project": "solr",
  "jira_id": "3644",
  "commit": "0b734cfe",
  "classification": {
    "singleLine": false
  },
  "patch": "diff --git a/lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java b/lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java\nindex c38a9b7f52..0a48a8685d 100644\n--- a/lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java\n+++ b/lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java\n@@ -24,7 +24,6 @@ import java.util.Collection;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n \n@@ -750,7 +749,6 @@ public class MemoryIndex {\n     \n     private MemoryIndexReader() {\n       super(); // avoid as much superclass baggage as possible\n-      readerFinishedListeners = Collections.synchronizedSet(new HashSet<ReaderFinishedListener>());\n     }\n     \n     private Info getInfo(String fieldName) {\ndiff --git a/lucene/src/java/org/apache/lucene/index/DirectoryReader.java b/lucene/src/java/org/apache/lucene/index/DirectoryReader.java\nindex ca8a9ad6aa..b5dadbfe64 100644\n--- a/lucene/src/java/org/apache/lucene/index/DirectoryReader.java\n+++ b/lucene/src/java/org/apache/lucene/index/DirectoryReader.java\n@@ -25,12 +25,10 @@ import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.lucene.store.Directory;\n import org.apache.lucene.store.IOContext;\n import org.apache.lucene.util.IOUtils;\n-import org.apache.lucene.util.MapBackedSet;\n \n /** \n  * An IndexReader which reads indexes with multiple segments.\n@@ -43,15 +41,12 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n   private final boolean applyAllDeletes;\n   \n   DirectoryReader(SegmentReader[] readers, Directory directory, IndexWriter writer,\n-    SegmentInfos sis, int termInfosIndexDivisor, boolean applyAllDeletes,\n-    Collection<ReaderFinishedListener> readerFinishedListeners\n-  ) throws IOException {\n+    SegmentInfos sis, int termInfosIndexDivisor, boolean applyAllDeletes) throws IOException {\n     super(readers);\n     this.directory = directory;\n     this.writer = writer;\n     this.segmentInfos = sis;\n     this.termInfosIndexDivisor = termInfosIndexDivisor;\n-    this.readerFinishedListeners = readerFinishedListeners;\n     this.applyAllDeletes = applyAllDeletes;\n   }\n \n@@ -60,8 +55,6 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n     return (IndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n       @Override\n       protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n-        final Collection<ReaderFinishedListener> readerFinishedListeners =\n-          new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n         SegmentInfos sis = new SegmentInfos();\n         sis.read(directory, segmentFileName);\n         final SegmentReader[] readers = new SegmentReader[sis.size()];\n@@ -70,7 +63,6 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n           boolean success = false;\n           try {\n             readers[i] = SegmentReader.get(sis.info(i), termInfosIndexDivisor, IOContext.READ);\n-            readers[i].readerFinishedListeners = readerFinishedListeners;\n             success = true;\n           } catch(IOException ex) {\n             prior = ex;\n@@ -79,8 +71,7 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n               IOUtils.closeWhileHandlingException(prior, readers);\n           }\n         }\n-        return new DirectoryReader(readers, directory, null, sis, termInfosIndexDivisor,\n-          false, readerFinishedListeners);\n+        return new DirectoryReader(readers, directory, null, sis, termInfosIndexDivisor, false);\n       }\n     }.run(commit);\n   }\n@@ -105,7 +96,6 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n         assert info.dir == dir;\n         final SegmentReader reader = writer.readerPool.getReadOnlyClone(info, IOContext.READ);\n         if (reader.numDocs() > 0 || writer.getKeepFullyDeletedSegments()) {\n-          reader.readerFinishedListeners = writer.getReaderFinishedListeners();\n           readers.add(reader);\n           infosUpto++;\n         } else {\n@@ -121,14 +111,12 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n       }\n     }\n     return new DirectoryReader(readers.toArray(new SegmentReader[readers.size()]),\n-      dir, writer, segmentInfos, writer.getConfig().getReaderTermsIndexDivisor(),\n-      applyAllDeletes, writer.getReaderFinishedListeners());\n+      dir, writer, segmentInfos, writer.getConfig().getReaderTermsIndexDivisor(), applyAllDeletes);\n   }\n \n   /** This constructor is only used for {@link #doOpenIfChanged()} */\n   static DirectoryReader open(Directory directory, IndexWriter writer, SegmentInfos infos, SegmentReader[] oldReaders,\n-    boolean doClone, int termInfosIndexDivisor, Collection<ReaderFinishedListener> readerFinishedListeners\n-  ) throws IOException {\n+    boolean doClone, int termInfosIndexDivisor) throws IOException {\n     // we put the old SegmentReaders in a map, that allows us\n     // to lookup a reader using its segment name\n     final Map<String,Integer> segmentReaders = new HashMap<String,Integer>();\n@@ -168,7 +156,6 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n \n           // this is a new reader; in case we hit an exception we can close it safely\n           newReader = SegmentReader.get(infos.info(i), termInfosIndexDivisor, IOContext.READ);\n-          newReader.readerFinishedListeners = readerFinishedListeners;\n           readerShared[i] = false;\n           newReaders[i] = newReader;\n         } else {\n@@ -179,7 +166,6 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n             readerShared[i] = true;\n             newReaders[i].incRef();\n           } else {\n-            assert newReader.readerFinishedListeners == readerFinishedListeners;\n             readerShared[i] = false;\n             // Steal ref returned to us by reopenSegment:\n             newReaders[i] = newReader;\n@@ -212,9 +198,8 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n         if (prior != null) throw prior;\n       }\n     }    \n-    return new DirectoryReader(newReaders,\n-      directory, writer, infos, termInfosIndexDivisor,\n-      false, readerFinishedListeners);\n+    return new DirectoryReader(newReaders, directory, writer, \n+        infos, termInfosIndexDivisor, false);\n   }\n \n   /** {@inheritDoc} */\n@@ -242,7 +227,6 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n   public final synchronized Object clone() {\n     try {\n       DirectoryReader newReader = doOpenIfChanged((SegmentInfos) segmentInfos.clone(), true, writer);\n-      assert newReader.readerFinishedListeners != null;\n       return newReader;\n     } catch (Exception ex) {\n       throw new RuntimeException(ex);\n@@ -295,7 +279,6 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n       return null;\n     }\n \n-    reader.readerFinishedListeners = readerFinishedListeners;\n     return reader;\n   }\n \n@@ -325,7 +308,7 @@ final class DirectoryReader extends BaseMultiReader<SegmentReader> {\n   }\n \n   private synchronized DirectoryReader doOpenIfChanged(SegmentInfos infos, boolean doClone, IndexWriter writer) throws CorruptIndexException, IOException {\n-    return DirectoryReader.open(directory, writer, infos, subReaders, doClone, termInfosIndexDivisor, readerFinishedListeners);\n+    return DirectoryReader.open(directory, writer, infos, subReaders, doClone, termInfosIndexDivisor);\n   }\n \n   /** Version number when this IndexReader was opened. */\ndiff --git a/lucene/src/java/org/apache/lucene/index/FilterIndexReader.java b/lucene/src/java/org/apache/lucene/index/FilterIndexReader.java\nindex cdeb70c91f..6718dcdce2 100644\n--- a/lucene/src/java/org/apache/lucene/index/FilterIndexReader.java\n+++ b/lucene/src/java/org/apache/lucene/index/FilterIndexReader.java\n@@ -20,13 +20,11 @@ package org.apache.lucene.index;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.util.Bits;\n import org.apache.lucene.util.BytesRef;\n-import org.apache.lucene.util.MapBackedSet;\n \n import java.io.IOException;\n import java.util.Collection;\n import java.util.Map;\n import java.util.Comparator;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**  A <code>FilterIndexReader</code> contains another IndexReader, which it\n  * uses as its basic source of data, possibly transforming the data along the\n@@ -282,7 +280,6 @@ public class FilterIndexReader extends IndexReader {\n   public FilterIndexReader(IndexReader in) {\n     super();\n     this.in = in;\n-    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n   }\n \n   @Override\n@@ -408,18 +405,6 @@ public class FilterIndexReader extends IndexReader {\n     return buffer.toString();\n   }\n \n-  @Override\n-  public void addReaderFinishedListener(ReaderFinishedListener listener) {\n-    super.addReaderFinishedListener(listener);\n-    in.addReaderFinishedListener(listener);\n-  }\n-\n-  @Override\n-  public void removeReaderFinishedListener(ReaderFinishedListener listener) {\n-    super.removeReaderFinishedListener(listener);\n-    in.removeReaderFinishedListener(listener);\n-  }\n-\n   @Override\n   public DocValues docValues(String field) throws IOException {\n     ensureOpen();\ndiff --git a/lucene/src/java/org/apache/lucene/index/IndexReader.java b/lucene/src/java/org/apache/lucene/index/IndexReader.java\nindex 4e77cdf42a..67899420d9 100644\n--- a/lucene/src/java/org/apache/lucene/index/IndexReader.java\n+++ b/lucene/src/java/org/apache/lucene/index/IndexReader.java\n@@ -24,16 +24,18 @@ import java.io.IOException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.lucene.document.Document;\n import org.apache.lucene.document.DocumentStoredFieldVisitor;\n-import org.apache.lucene.search.FieldCache; // javadocs\n import org.apache.lucene.search.SearcherManager; // javadocs\n import org.apache.lucene.store.*;\n import org.apache.lucene.util.ArrayUtil;\n import org.apache.lucene.util.Bits;\n import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.MapBackedSet;\n import org.apache.lucene.util.CommandLineUtil;\n import org.apache.lucene.util.ReaderUtil;         // for javadocs\n \n@@ -73,62 +75,40 @@ public abstract class IndexReader implements Cloneable,Closeable {\n \n   /**\n    * A custom listener that's invoked when the IndexReader\n-   * is finished.\n-   *\n-   * <p>For a SegmentReader, this listener is called only\n-   * once all SegmentReaders sharing the same core are\n-   * closed.  At this point it is safe for apps to evict\n-   * this reader from any caches keyed on {@link\n-   * #getCoreCacheKey}.  This is the same interface that\n-   * {@link FieldCache} uses, internally, to evict\n-   * entries.</p>\n-   *\n-   * <p>For other readers, this listener is called when they\n-   * are closed.</p>\n+   * is closed.\n    *\n    * @lucene.experimental\n    */\n-  public static interface ReaderFinishedListener {\n-    public void finished(IndexReader reader);\n+  public static interface ReaderClosedListener {\n+    public void onClose(IndexReader reader);\n   }\n \n-  // Impls must set this if they may call add/removeReaderFinishedListener:\n-  protected volatile Collection<ReaderFinishedListener> readerFinishedListeners;\n+  private final Set<ReaderClosedListener> readerClosedListeners = \n+      new MapBackedSet<ReaderClosedListener>(new ConcurrentHashMap<ReaderClosedListener, Boolean>());\n \n-  /** Expert: adds a {@link ReaderFinishedListener}.  The\n-   * provided listener is also added to any sub-readers, if\n-   * this is a composite reader.  Also, any reader reopened\n-   * or cloned from this one will also copy the listeners at\n-   * the time of reopen.\n+  /** Expert: adds a {@link ReaderClosedListener}.  The\n+   * provided listener will be invoked when this reader is closed.\n    *\n    * @lucene.experimental */\n-  public void addReaderFinishedListener(ReaderFinishedListener listener) {\n+  public final void addReaderClosedListener(ReaderClosedListener listener) {\n     ensureOpen();\n-    readerFinishedListeners.add(listener);\n+    readerClosedListeners.add(listener);\n   }\n \n-  /** Expert: remove a previously added {@link ReaderFinishedListener}.\n+  /** Expert: remove a previously added {@link ReaderClosedListener}.\n    *\n    * @lucene.experimental */\n-  public void removeReaderFinishedListener(ReaderFinishedListener listener) {\n+  public final void removeReaderClosedListener(ReaderClosedListener listener) {\n     ensureOpen();\n-    readerFinishedListeners.remove(listener);\n+    readerClosedListeners.remove(listener);\n   }\n \n-  protected void notifyReaderFinishedListeners() {\n-    // Defensive (should never be null -- all impls must set\n-    // this):\n-    if (readerFinishedListeners != null) {\n-      for(ReaderFinishedListener listener : readerFinishedListeners) {\n-        listener.finished(this);\n-      }\n+  private final void notifyReaderClosedListeners() {\n+    for(ReaderClosedListener listener : readerClosedListeners) {\n+      listener.onClose(this);\n     }\n   }\n \n-  protected void readerFinished() {\n-    notifyReaderFinishedListeners();\n-  }\n-\n   /**\n    * Constants describing field properties, for example used for\n    * {@link IndexReader#getFieldNames(FieldOption)}.\n@@ -267,7 +247,7 @@ public abstract class IndexReader implements Cloneable,Closeable {\n           refCount.incrementAndGet();\n         }\n       }\n-      readerFinished();\n+      notifyReaderClosedListeners();\n     } else if (rc < 0) {\n       throw new IllegalStateException(\"too many decRef calls: refCount is \" + rc + \" after decrement\");\n     }\ndiff --git a/lucene/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/src/java/org/apache/lucene/index/IndexWriter.java\nindex de8d583147..7d4295a0b8 100644\n--- a/lucene/src/java/org/apache/lucene/index/IndexWriter.java\n+++ b/lucene/src/java/org/apache/lucene/index/IndexWriter.java\n@@ -29,7 +29,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.ConcurrentHashMap;\n import java.util.regex.Pattern;\n \n import org.apache.lucene.analysis.Analyzer;\n@@ -53,7 +52,6 @@ import org.apache.lucene.util.Constants;\n import org.apache.lucene.util.IOUtils;\n import org.apache.lucene.util.InfoStream;\n import org.apache.lucene.util.ThreadInterruptedException;\n-import org.apache.lucene.util.MapBackedSet;\n import org.apache.lucene.util.TwoPhaseCommit;\n \n /**\n@@ -393,13 +391,6 @@ public class IndexWriter implements Closeable, TwoPhaseCommit {\n     return r;\n   }\n \n-  // Used for all SegmentReaders we open\n-  private final Collection<IndexReader.ReaderFinishedListener> readerFinishedListeners = new MapBackedSet<IndexReader.ReaderFinishedListener>(new ConcurrentHashMap<IndexReader.ReaderFinishedListener,Boolean>());\n-\n-  Collection<IndexReader.ReaderFinishedListener> getReaderFinishedListeners() throws IOException {\n-    return readerFinishedListeners;\n-  }\n-\n   /** Holds shared SegmentReader instances. IndexWriter uses\n    *  SegmentReaders for 1) applying deletes, 2) doing\n    *  merges, 3) handing out a real-time reader.  This pool\n@@ -703,7 +694,6 @@ public class IndexWriter implements Closeable, TwoPhaseCommit {\n         // synchronized\n         // Returns a ref, which we xfer to readerMap:\n         sr = SegmentReader.getRW(info, doOpenStores, context.context == IOContext.Context.MERGE ? -1 : config.getReaderTermsIndexDivisor(), context);\n-        sr.readerFinishedListeners = readerFinishedListeners;\n \n         if (info.dir == directory) {\n           // Only pool if reader is not external\ndiff --git a/lucene/src/java/org/apache/lucene/index/MultiReader.java b/lucene/src/java/org/apache/lucene/index/MultiReader.java\nindex 6b6e88aed3..8250541229 100644\n--- a/lucene/src/java/org/apache/lucene/index/MultiReader.java\n+++ b/lucene/src/java/org/apache/lucene/index/MultiReader.java\n@@ -18,10 +18,6 @@ package org.apache.lucene.index;\n  */\n \n import java.io.IOException;\n-import java.util.Collection;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.apache.lucene.util.MapBackedSet;\n \n /** An IndexReader which reads multiple indexes, appending\n  *  their content. */\n@@ -45,7 +41,6 @@ public class MultiReader extends BaseMultiReader<IndexReader> {\n    */\n   public MultiReader(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n     super(subReaders.clone());\n-    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n     decrefOnClose = new boolean[subReaders.length];\n     for (int i = 0; i < subReaders.length; i++) {\n       if (!closeSubReaders) {\n@@ -58,12 +53,10 @@ public class MultiReader extends BaseMultiReader<IndexReader> {\n   }\n   \n   // used only by openIfChaged\n-  private MultiReader(IndexReader[] subReaders, boolean[] decrefOnClose,\n-                      Collection<ReaderFinishedListener> readerFinishedListeners)\n+  private MultiReader(IndexReader[] subReaders, boolean[] decrefOnClose)\n                       throws IOException {\n     super(subReaders);\n     this.decrefOnClose = decrefOnClose;\n-    this.readerFinishedListeners = readerFinishedListeners;\n   }\n \n   @Override\n@@ -125,7 +118,7 @@ public class MultiReader extends BaseMultiReader<IndexReader> {\n           newDecrefOnClose[i] = true;\n         }\n       }\n-      return new MultiReader(newSubReaders, newDecrefOnClose, readerFinishedListeners);\n+      return new MultiReader(newSubReaders, newDecrefOnClose);\n     } else {\n       return null;\n     }\n@@ -169,20 +162,4 @@ public class MultiReader extends BaseMultiReader<IndexReader> {\n   public long getVersion() {\n     throw new UnsupportedOperationException(\"MultiReader does not support this method.\");\n   }\n-\n-  @Override\n-  public void addReaderFinishedListener(ReaderFinishedListener listener) {\n-    super.addReaderFinishedListener(listener);\n-    for(IndexReader sub : subReaders) {\n-      sub.addReaderFinishedListener(listener);\n-    }\n-  }\n-\n-  @Override\n-  public void removeReaderFinishedListener(ReaderFinishedListener listener) {\n-    super.removeReaderFinishedListener(listener);\n-    for(IndexReader sub : subReaders) {\n-      sub.removeReaderFinishedListener(listener);\n-    }\n-  }\n }\ndiff --git a/lucene/src/java/org/apache/lucene/index/ParallelReader.java b/lucene/src/java/org/apache/lucene/index/ParallelReader.java\nindex 9d29ad32bd..667543136f 100644\n--- a/lucene/src/java/org/apache/lucene/index/ParallelReader.java\n+++ b/lucene/src/java/org/apache/lucene/index/ParallelReader.java\n@@ -19,11 +19,9 @@ package org.apache.lucene.index;\n \n import org.apache.lucene.util.Bits;\n import org.apache.lucene.util.BytesRef;\n-import org.apache.lucene.util.MapBackedSet;\n \n import java.io.IOException;\n import java.util.*;\n-import java.util.concurrent.ConcurrentHashMap;\n \n \n /** An IndexReader which reads multiple, parallel indexes.  Each index added\n@@ -70,7 +68,6 @@ public class ParallelReader extends IndexReader {\n   public ParallelReader(boolean closeSubReaders) throws IOException {\n     super();\n     this.incRefReaders = !closeSubReaders;\n-    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n   }\n \n   /** {@inheritDoc} */\n@@ -444,22 +441,6 @@ public class ParallelReader extends IndexReader {\n     return topLevelReaderContext;\n   }\n \n-  @Override\n-  public void addReaderFinishedListener(ReaderFinishedListener listener) {\n-    super.addReaderFinishedListener(listener);\n-    for (IndexReader reader : readers) {\n-      reader.addReaderFinishedListener(listener);\n-    }\n-  }\n-\n-  @Override\n-  public void removeReaderFinishedListener(ReaderFinishedListener listener) {\n-    super.removeReaderFinishedListener(listener);\n-    for (IndexReader reader : readers) {\n-      reader.removeReaderFinishedListener(listener);\n-    }\n-  }\n-\n   // TODO: I suspect this is completely untested!!!!!\n   @Override\n   public DocValues docValues(String field) throws IOException {\ndiff --git a/lucene/src/java/org/apache/lucene/index/SegmentCoreReaders.java b/lucene/src/java/org/apache/lucene/index/SegmentCoreReaders.java\nindex 6f6d7d1cf8..232496b87f 100644\n--- a/lucene/src/java/org/apache/lucene/index/SegmentCoreReaders.java\n+++ b/lucene/src/java/org/apache/lucene/index/SegmentCoreReaders.java\n@@ -18,8 +18,11 @@ package org.apache.lucene.index;\n  */\n \n import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import org.apache.lucene.index.SegmentReader.CoreClosedListener;\n import org.apache.lucene.index.codecs.Codec;\n import org.apache.lucene.index.codecs.NormsReader;\n import org.apache.lucene.index.codecs.PerDocProducer;\n@@ -31,6 +34,7 @@ import org.apache.lucene.store.CompoundFileDirectory;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.store.IOContext;\n import org.apache.lucene.util.IOUtils;\n+import org.apache.lucene.util.MapBackedSet;\n \n /** Holds core readers that are shared (unchanged) when\n  * SegmentReader is cloned or reopened */\n@@ -63,7 +67,8 @@ final class SegmentCoreReaders {\n   CompoundFileDirectory cfsReader;\n   CompoundFileDirectory storeCFSReader;\n \n-  \n+  final Set<CoreClosedListener> coreClosedListeners = \n+      new MapBackedSet<CoreClosedListener>(new ConcurrentHashMap<CoreClosedListener, Boolean>());\n   \n   SegmentCoreReaders(SegmentReader owner, Directory dir, SegmentInfo si, IOContext context, int termsIndexDivisor) throws IOException {\n     \n@@ -133,9 +138,8 @@ final class SegmentCoreReaders {\n     if (ref.decrementAndGet() == 0) {\n       IOUtils.close(fields, perDocProducer, termVectorsReaderOrig,\n           fieldsReaderOrig, cfsReader, storeCFSReader, norms);\n-      // Now, notify any ReaderFinished listeners:\n-      if (owner != null) {\n-        owner.notifyReaderFinishedListeners();\n+      for (CoreClosedListener listener : coreClosedListeners) {\n+        listener.onClose(owner);\n       }\n     }\n   }\ndiff --git a/lucene/src/java/org/apache/lucene/index/SegmentReader.java b/lucene/src/java/org/apache/lucene/index/SegmentReader.java\nindex 2b26fc6f57..a528dbe324 100644\n--- a/lucene/src/java/org/apache/lucene/index/SegmentReader.java\n+++ b/lucene/src/java/org/apache/lucene/index/SegmentReader.java\n@@ -30,6 +30,7 @@ import org.apache.lucene.index.FieldInfo.IndexOptions;\n import org.apache.lucene.index.codecs.PerDocProducer;\n import org.apache.lucene.index.codecs.StoredFieldsReader;\n import org.apache.lucene.index.codecs.TermVectorsReader;\n+import org.apache.lucene.search.FieldCache; // javadocs\n import org.apache.lucene.store.IOContext;\n import org.apache.lucene.util.BitVector;\n import org.apache.lucene.util.Bits;\n@@ -414,16 +415,6 @@ public final class SegmentReader extends IndexReader implements Cloneable {\n     return core.termsIndexDivisor;\n   }\n   \n-  @Override\n-  protected void readerFinished() {\n-    // Do nothing here -- we have more careful control on\n-    // when to notify that a SegmentReader has finished,\n-    // because a given core is shared across many cloned\n-    // SegmentReaders.  We only notify once that core is no\n-    // longer used (all SegmentReaders sharing it have been\n-    // closed).\n-  }\n-  \n   @Override\n   public DocValues docValues(String field) throws IOException {\n     ensureOpen();\n@@ -474,7 +465,6 @@ public final class SegmentReader extends IndexReader implements Cloneable {\n       core.incRef();\n       clone.core = core;\n       clone.pendingDeleteCount = pendingDeleteCount;\n-      clone.readerFinishedListeners = readerFinishedListeners;\n \n       if (!openReadOnly && hasChanges) {\n         // My pending changes transfer to the new reader\n@@ -607,4 +597,33 @@ public final class SegmentReader extends IndexReader implements Cloneable {\n       pendingDeleteCount++;\n     }\n   }\n+  \n+  /**\n+   * Called when the shared core for this SegmentReader\n+   * is closed.\n+   * <p>\n+   * This listener is called only once all SegmentReaders \n+   * sharing the same core are closed.  At this point it \n+   * is safe for apps to evict this reader from any caches \n+   * keyed on {@link #getCoreCacheKey}.  This is the same \n+   * interface that {@link FieldCache} uses, internally, \n+   * to evict entries.</p>\n+   * \n+   * @lucene.experimental\n+   */\n+  public static interface CoreClosedListener {\n+    public void onClose(SegmentReader owner);\n+  }\n+  \n+  /** Expert: adds a CoreClosedListener to this reader's shared core */\n+  public void addCoreClosedListener(CoreClosedListener listener) {\n+    ensureOpen();\n+    core.coreClosedListeners.add(listener);\n+  }\n+  \n+  /** Expert: removes a CoreClosedListener from this reader's shared core */\n+  public void removeCoreClosedListener(CoreClosedListener listener) {\n+    ensureOpen();\n+    core.coreClosedListeners.remove(listener);\n+  }\n }\ndiff --git a/lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java b/lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java\nindex 9f89971572..7e98217b51 100644\n--- a/lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java\n+++ b/lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java\n@@ -32,6 +32,7 @@ import org.apache.lucene.index.DocsEnum;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.index.MultiFields;\n import org.apache.lucene.index.OrdTermState;\n+import org.apache.lucene.index.SegmentReader;\n import org.apache.lucene.index.TermState;\n import org.apache.lucene.index.Terms;\n import org.apache.lucene.index.TermsEnum;\n@@ -146,10 +147,11 @@ class FieldCacheImpl implements FieldCache {\n   static final class StopFillCacheException extends RuntimeException {\n   }\n   \n-  final static IndexReader.ReaderFinishedListener purgeReader = new IndexReader.ReaderFinishedListener() {\n+  // per-segment fieldcaches don't purge until the shared core closes.\n+  final static SegmentReader.CoreClosedListener purgeCore = new SegmentReader.CoreClosedListener() {\n     // @Override -- not until Java 1.6\n-    public void finished(IndexReader reader) {\n-      FieldCache.DEFAULT.purge(reader);\n+    public void onClose(SegmentReader owner) {\n+      FieldCache.DEFAULT.purge(owner);\n     }\n   };\n \n@@ -188,7 +190,16 @@ class FieldCacheImpl implements FieldCache {\n           // First time this reader is using FieldCache\n           innerCache = new HashMap<Entry,Object>();\n           readerCache.put(readerKey, innerCache);\n-          reader.addReaderFinishedListener(purgeReader);\n+          if (reader instanceof SegmentReader) {\n+            ((SegmentReader) reader).addCoreClosedListener(purgeCore);\n+          } else {\n+            reader.addReaderClosedListener(new IndexReader.ReaderClosedListener() {\n+              @Override\n+              public void onClose(IndexReader reader) {\n+                FieldCache.DEFAULT.purge(reader);\n+              }\n+            });\n+          }\n         }\n         if (innerCache.get(key) == null) {\n           innerCache.put(key, value);\n@@ -209,7 +220,16 @@ class FieldCacheImpl implements FieldCache {\n           // First time this reader is using FieldCache\n           innerCache = new HashMap<Entry,Object>();\n           readerCache.put(readerKey, innerCache);\n-          reader.addReaderFinishedListener(purgeReader);\n+          if (reader instanceof SegmentReader) {\n+            ((SegmentReader) reader).addCoreClosedListener(purgeCore);\n+          } else {\n+            reader.addReaderClosedListener(new IndexReader.ReaderClosedListener() {\n+              @Override\n+              public void onClose(IndexReader reader) {\n+                FieldCache.DEFAULT.purge(reader);\n+              }\n+            });           \n+          }\n           value = null;\n         } else {\n           value = innerCache.get(key);\n",
  "files": 10,
  "linesAdd": 91,
  "linesRem": 154,
  "failing_tests": [],
  "nb_test": 0,
  "nb_failure": 0,
  "nb_error": 0,
  "nb_skipped": 0
}