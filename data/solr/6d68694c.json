{
  "project": "solr",
  "jira_id": "6255",
  "commit": "6d68694c",
  "classification": {
    "singleLine": false
  },
  "patch": "diff --git a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java\nindex 3da6c85bac..5b2e661352 100644\n--- a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java\n+++ b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java\n@@ -42,12 +42,25 @@ import org.apache.lucene.util.ToStringUtils;\n  * A PhraseQuery is built by QueryParser for input like <code>\"new york\"</code>.\n  * \n  * <p>This query may be combined with other terms or queries with a {@link BooleanQuery}.\n+ *\n+ * <b>NOTE</b>: Leading holes don't have any particular meaning for this query\n+ * and will be ignored. For instance this query:\n+ * <pre class=\"prettyprint\">\n+ * PhraseQuery pq = new PhraseQuery();\n+ * pq.add(new Term(\"body\", \"one\"), 4);\n+ * pq.add(new Term(\"body\", \"two\"), 5);\n+ * </pre>\n+ * is equivalent to the below query:\n+ * <pre class=\"prettyprint\">\n+ * PhraseQuery pq = new PhraseQuery();\n+ * pq.add(new Term(\"body\", \"one\"), 0);\n+ * pq.add(new Term(\"body\", \"two\"), 1);\n+ * </pre>\n  */\n public class PhraseQuery extends Query {\n   private String field;\n   private ArrayList<Term> terms = new ArrayList<>(4);\n   private ArrayList<Integer> positions = new ArrayList<>(4);\n-  private int maxPosition = 0;\n   private int slop = 0;\n \n   /** Constructs an empty phrase query. */\n@@ -82,8 +95,9 @@ public class PhraseQuery extends Query {\n    */\n   public void add(Term term) {\n     int position = 0;\n-    if(positions.size() > 0)\n-        position = positions.get(positions.size()-1).intValue() + 1;\n+    if (positions.size() > 0) {\n+      position = positions.get(positions.size()-1) + 1;\n+    }\n \n     add(term, position);\n   }\n@@ -96,6 +110,16 @@ public class PhraseQuery extends Query {\n    * \n    */\n   public void add(Term term, int position) {\n+    if (positions.size() > 0) {\n+      final int previousPosition = positions.get(positions.size()-1);\n+      if (position < previousPosition) {\n+        throw new IllegalArgumentException(\"Positions must be added in order. Got position=\"\n+            + position + \" while previous position was \" + previousPosition);\n+      }\n+    } else if (position < 0) {\n+      throw new IllegalArgumentException(\"Positions must be positive, got \" + position);\n+    }\n+\n     if (terms.size() == 0) {\n       field = term.field();\n     } else if (!term.field().equals(field)) {\n@@ -104,7 +128,6 @@ public class PhraseQuery extends Query {\n \n     terms.add(term);\n     positions.add(Integer.valueOf(position));\n-    if (position > maxPosition) maxPosition = position;\n   }\n \n   /** Returns the set of terms in this phrase. */\n@@ -132,9 +155,22 @@ public class PhraseQuery extends Query {\n       TermQuery tq = new TermQuery(terms.get(0));\n       tq.setBoost(getBoost());\n       return tq;\n-    } else\n+    } else if (positions.get(0).intValue() != 0) {\n+      // PhraseWeight requires that positions start at 0 so we need to rebase\n+      // positions\n+      final Term[] terms = getTerms();\n+      final int[] positions = getPositions();\n+      PhraseQuery rewritten = new PhraseQuery();\n+      for (int i = 0; i < terms.length; ++i) {\n+        rewritten.add(terms[i], positions[i] - positions[0]);\n+      }\n+      rewritten.setBoost(getBoost());\n+      rewritten.setSlop(getSlop());\n+      return rewritten;\n+    } else {\n       return super.rewrite(reader);\n     }\n+  }\n \n   static class PostingsAndFreq implements Comparable<PostingsAndFreq> {\n     final PostingsEnum postings;\n@@ -217,6 +253,12 @@ public class PhraseQuery extends Query {\n     public PhraseWeight(IndexSearcher searcher, boolean needsScores)\n       throws IOException {\n       super(PhraseQuery.this);\n+      final int[] positions = PhraseQuery.this.getPositions();\n+      if (positions.length < 2) {\n+        throw new IllegalStateException(\"PhraseWeight does not support less than 2 terms, call rewrite first\");\n+      } else if (positions[0] != 0) {\n+        throw new IllegalStateException(\"PhraseWeight requires that the first position is 0, call rewrite first\");\n+      }\n       this.needsScores = needsScores;\n       this.similarity = searcher.getSimilarity();\n       final IndexReaderContext context = searcher.getTopReaderContext();\n@@ -340,6 +382,12 @@ public class PhraseQuery extends Query {\n     }\n \n     buffer.append(\"\\\"\");\n+    final int maxPosition;\n+    if (positions.isEmpty()) {\n+      maxPosition = -1;\n+    } else {\n+      maxPosition = positions.get(positions.size() - 1);\n+    }\n     String[] pieces = new String[maxPosition + 1];\n     for (int i = 0; i < terms.size(); i++) {\n       int pos = positions.get(i).intValue();\n",
  "files": 1,
  "linesAdd": 53,
  "linesRem": 5,
  "failing_tests": [],
  "nb_test": 0,
  "nb_failure": 0,
  "nb_error": 0,
  "nb_skipped": 0
}