{
  "files": 4, 
  "singleLine": false, 
  "nb_error": 0, 
  "failing_tests": [
    "testMultithreadedLocking(org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategyTest)"
  ], 
  "nb_test": 3269, 
  "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\nindex 206bb98..1c28345 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n@@ -54,7 +54,7 @@ public class FileOperations implements GenericFileOperations<File> {\n         this.endpoint = (FileEndpoint) endpoint;\n     }\n \n-    public boolean deleteFile(String name) throws GenericFileOperationFailedException {        \n+    public boolean deleteFile(String name) throws GenericFileOperationFailedException {\n         File file = new File(name);\n         return FileUtil.deleteFile(file);\n     }\n@@ -71,7 +71,7 @@ public class FileOperations implements GenericFileOperations<File> {\n     }\n \n     public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {\n-        ObjectHelper.notNull(endpoint, \"endpoint\");       \n+        ObjectHelper.notNull(endpoint, \"endpoint\");\n \n         // always create endpoint defined directory\n         if (endpoint.isAutoCreate() && !endpoint.getFile().exists()) {\n@@ -106,12 +106,17 @@ public class FileOperations implements GenericFileOperations<File> {\n             }\n         }\n \n-        if (path.isDirectory() && path.exists()) {\n-            // the directory already exists\n-            return true;\n-        } else {\n-            LOG.trace(\"Building directory: {}\", path);\n-            return path.mkdirs();\n+        // We need to make sure that this is thread-safe and only one thread tries to create the path directory at the same time.\n+        synchronized (this) {\n+            if (path.isDirectory() && path.exists()) {\n+                // the directory already exists\n+                return true;\n+            } else {\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Building directory: \" + path);\n+                }\n+                return path.mkdirs();\n+            }\n         }\n     }\n \n@@ -152,7 +157,9 @@ public class FileOperations implements GenericFileOperations<File> {\n         if (file.exists()) {\n             if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n                 // ignore but indicate that the file was written\n-                LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"An existing file already exists: \" + file + \". Ignore and do not override it.\");\n+                }\n                 return true;\n             } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n                 throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\n@@ -168,7 +175,7 @@ public class FileOperations implements GenericFileOperations<File> {\n             // is the body file based\n             File source = null;\n             // get the File Object from in message\n-            source = exchange.getIn().getBody(File.class);            \n+            source = exchange.getIn().getBody(File.class);\n \n             if (source != null) {\n                 // okay we know the body is a file type\n@@ -222,13 +229,17 @@ public class FileOperations implements GenericFileOperations<File> {\n             }\n             if (last != null) {\n                 boolean result = file.setLastModified(last);\n-                LOG.trace(\"Keeping last modified timestamp: {} on file: {} with result: {}\", new Object[]{last, file, result});\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Keeping last modified timestamp: \" + last + \" on file: \" + file + \" with result: \" + result);\n+                }\n             }\n         }\n     }\n \n     private boolean writeFileByLocalWorkPath(File source, File file) {\n-        LOG.trace(\"Using local work file being renamed from: {} to: {}\", source, file);\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Using local work file being renamed from: \" + source + \" to: \" + file);\n+        }\n \n         return FileUtil.renameFile(source, file);\n     }\n@@ -239,7 +250,9 @@ public class FileOperations implements GenericFileOperations<File> {\n         try {\n             out = prepareOutputFileChannel(target, out);\n \n-            LOG.trace(\"Using FileChannel to transfer from: {} to: {}\", in, out);\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Using FileChannel to transfer from: \" + in + \" to: \" + out);\n+            }\n \n             long size = in.size();\n             long position = 0;\n@@ -257,7 +270,9 @@ public class FileOperations implements GenericFileOperations<File> {\n         try {\n             out = prepareOutputFileChannel(target, out);\n \n-            LOG.trace(\"Using InputStream to transfer from: {} to: {}\", in, out);\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Using InputStream to transfer from: \" + in + \" to: \" + out);\n+            }\n             int size = endpoint.getBufferSize();\n             byte[] buffer = new byte[size];\n             ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\n@@ -277,7 +292,7 @@ public class FileOperations implements GenericFileOperations<File> {\n \n     /**\n      * Creates and prepares the output file channel. Will position itself in correct position if the file is writable\n-     *  eg. it should append or override any existing content.\n+     * eg. it should append or override any existing content.\n      */\n     private FileChannel prepareOutputFileChannel(File target, FileChannel out) throws IOException {\n         if (endpoint.getFileExist() == GenericFileExist.Append) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\nindex 9235dcc..8f5ff7b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\n@@ -29,19 +29,22 @@ public class GenericFileDeleteProcessStrategy<T> extends GenericFileProcessStrat\n \n     @Override\n     public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n-        // must invoke super\n-        boolean result = super.begin(operations, endpoint, exchange, file);\n-        if (!result) {\n-            return false;\n-        }\n+\n+        // We need to invoke super, but to the file that we are going to use for processing, so we do super after renaming.\n+        GenericFile<T> to = file;\n \n         if (beginRenamer != null) {\n             GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\n-            GenericFile<T> to = renameFile(operations, file, newName);\n+            to = renameFile(operations, file, newName);\n             if (to != null) {\n                 to.bindToExchange(exchange);\n             }\n         }\n+        // must invoke super\n+        boolean result = super.begin(operations, endpoint, exchange, to);\n+        if (!result) {\n+            return false;\n+        }\n \n         return true;\n     }\n@@ -79,7 +82,7 @@ public class GenericFileDeleteProcessStrategy<T> extends GenericFileProcessStrat\n             throw new GenericFileOperationFailedException(\"Cannot delete file: \" + file);\n         }\n     }\n-    \n+\n     @Override\n     public void rollback(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n         // must invoke super\n@@ -98,7 +101,7 @@ public class GenericFileDeleteProcessStrategy<T> extends GenericFileProcessStrat\n             renameFile(operations, file, newName);\n         }\n     }\n-    \n+\n     public GenericFileRenamer<T> getFailureRenamer() {\n         return failureRenamer;\n     }\n@@ -114,4 +117,4 @@ public class GenericFileDeleteProcessStrategy<T> extends GenericFileProcessStrat\n     public void setBeginRenamer(GenericFileRenamer<T> beginRenamer) {\n         this.beginRenamer = beginRenamer;\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\nindex 1e32688..943e71f 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\n@@ -31,19 +31,22 @@ public class GenericFileRenameProcessStrategy<T> extends GenericFileProcessStrat\n \n     @Override\n     public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n-        // must invoke super\n-        boolean result = super.begin(operations, endpoint, exchange, file);\n-        if (!result) {\n-            return false;\n-        }\n+\n+        // We need to invoke super, but to the file that we are going to use for processing, so we do super after renaming.\n+        GenericFile<T> to = file;\n \n         if (beginRenamer != null) {\n             GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\n-            GenericFile<T> to = renameFile(operations, file, newName);\n+            to = renameFile(operations, file, newName);\n             if (to != null) {\n                 to.bindToExchange(exchange);\n             }\n         }\n+        // must invoke super\n+        boolean result = super.begin(operations, endpoint, exchange, to);\n+        if (!result) {\n+            return false;\n+        }\n \n         return true;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\nindex 6d72d19..734a654 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n@@ -34,8 +34,6 @@ import org.slf4j.LoggerFactory;\n  */\n public class MarkerFileExclusiveReadLockStrategy implements GenericFileExclusiveReadLockStrategy<File> {\n     private static final transient Logger LOG = LoggerFactory.getLogger(MarkerFileExclusiveReadLockStrategy.class);\n-    private File lock;\n-    private String lockFileName;\n \n     public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) {\n         String dir = endpoint.getConfiguration().getDirectory();\n@@ -50,28 +48,25 @@ public class MarkerFileExclusiveReadLockStrategy implements GenericFileExclusive\n \n     public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations,\n                                             GenericFile<File> file, Exchange exchange) throws Exception {\n-        lockFileName = file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\n+        String lockFileName = getLockFileName(file);\n         LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\n \n         // create a plain file as marker filer for locking (do not use FileLock)\n-        lock = new File(lockFileName);\n+        File lock = new File(lockFileName);\n         boolean acquired = lock.createNewFile();\n-        if (!acquired) {\n-            lock = null;\n-\n-        }\n \n         return acquired;\n     }\n \n     public void releaseExclusiveReadLock(GenericFileOperations<File> operations,\n                                          GenericFile<File> file, Exchange exchange) throws Exception {\n-        if (lock != null) {\n-            LOG.trace(\"Unlocking file: {}\", lockFileName);\n+        String lockFileName = getLockFileName(file);\n+        File lock = new File(lockFileName);\n \n-            boolean deleted = FileUtil.deleteFile(lock);\n-            LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n-        }\n+        LOG.trace(\"Unlocking file: {}\", lockFileName);\n+\n+        boolean deleted = FileUtil.deleteFile(lock);\n+        LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n     }\n \n     public void setTimeout(long timeout) {\n@@ -101,4 +96,8 @@ public class MarkerFileExclusiveReadLockStrategy implements GenericFileExclusive\n         }\n     }\n \n+    private static String getLockFileName(GenericFile<File> file) {\n+        return file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\n+    }\n+\n }\n", 
  "project": "camel", 
  "linesAdd": 63, 
  "nb_skipped": 0, 
  "fix_commit": "9319e139", 
  "nb_failure": 1, 
  "id": "3789", 
  "linesRem": 43
}