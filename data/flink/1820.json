{"nb_failure": 18, "nb_error": 0, "failing_tests": ["DoubleParserTest>ParserTestBase.testInValidStringInIsolation:249 Parser accepted the invalid value  1.", "DoubleParserTest>ParserTestBase.testInValidStringsMixedIn:294 Parser accepted the invalid value  1.", "DoubleParserTest>ParserTestBase.testStaticParseMethodWithInvalidValues:362 Static parse method accepted invalid value", "IntParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "DoubleValueParserTest>ParserTestBase.testInValidStringInIsolation:249 Parser accepted the invalid value  1.", "DoubleValueParserTest>ParserTestBase.testInValidStringsMixedIn:294 Parser accepted the invalid value  1.", "ByteParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "IntValueParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "ShortParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "ByteValueParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "FloatParserTest>ParserTestBase.testInValidStringInIsolation:249 Parser accepted the invalid value  1.", "FloatParserTest>ParserTestBase.testInValidStringsMixedIn:294 Parser accepted the invalid value  1.", "LongValueParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "FloatParserTest>ParserTestBase.testStaticParseMethodWithInvalidValues:362 Static parse method accepted invalid value", "ShortValueParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "FloatValueParserTest>ParserTestBase.testInValidStringInIsolation:249 Parser accepted the invalid value  1.", "FloatValueParserTest>ParserTestBase.testInValidStringsMixedIn:294 Parser accepted the invalid value  1.", "LongParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string."], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\nindex 5858da2..09e517a 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\n@@ -21,22 +21,23 @@ package org.apache.flink.types.parser;\n \n \n public class ByteParser extends FieldParser<Byte> {\n-\t\n+\n \tprivate byte result;\n-\t\n+\n \t@Override\n \tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Byte reusable) {\n \t\tint val = 0;\n \t\tboolean neg = false;\n \n-\t\tfinal int delimLimit = limit-delimiter.length+1;\n-\t\t\n+\t\tfinal int delimLimit = limit - delimiter.length + 1;\n+\n \t\tif (bytes[startPos] == '-') {\n \t\t\tneg = true;\n \t\t\tstartPos++;\n-\t\t\t\n+\n \t\t\t// check for empty field with only the sign\n-\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n+\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, \n+\t\t\t\tdelimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n@@ -44,6 +45,10 @@ public class ByteParser extends FieldParser<Byte> {\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (byte) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -53,17 +58,17 @@ public class ByteParser extends FieldParser<Byte> {\n \t\t\t}\n \t\t\tval *= 10;\n \t\t\tval += bytes[i] - 48;\n-\t\t\t\n+\n \t\t\tif (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tthis.result = (byte) (neg ? -val : val);\n \t\treturn limit;\n \t}\n-\t\n+\n \t@Override\n \tpublic Byte createValue() {\n \t\treturn Byte.MIN_VALUE;\n@@ -73,43 +78,40 @@ public class ByteParser extends FieldParser<Byte> {\n \tpublic Byte getLastResult() {\n \t\treturn Byte.valueOf(this.result);\n \t}\n-\t\n+\n \t/**\n-\t * Static utility to parse a field of type byte from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type byte from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n-\t * \n-\t * @param bytes The bytes containing the text data that should be parsed.\n+\t *\n+\t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n-\t * @param length The length of the byte sequence (counting from the offset).\n-\t * \n+\t * @param length   The length of the byte sequence (counting from the offset).\n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final byte parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n-\t\n+\n \t/**\n-\t * Static utility to parse a field of type byte from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type byte from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n-\t * \n-\t * @param bytes The bytes containing the text data that should be parsed.\n-\t * @param startPos The offset to start the parsing.\n-\t * @param length The length of the byte sequence (counting from the offset).\n+\t *\n+\t * @param bytes     The bytes containing the text data that should be parsed.\n+\t * @param startPos  The offset to start the parsing.\n+\t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n-\t\t\n+\n \t\tif (bytes[startPos] == '-') {\n \t\t\tneg = true;\n \t\t\tstartPos++;\n@@ -118,17 +120,17 @@ public class ByteParser extends FieldParser<Byte> {\n \t\t\t\tthrow new NumberFormatException(\"Orphaned minus sign.\");\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (byte) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\n \t\t\t}\n \t\t\tval *= 10;\n \t\t\tval += bytes[startPos] - 48;\n-\t\t\t\n+\n \t\t\tif (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\n \t\t\t\tthrow new NumberFormatException(\"Value overflow/underflow\");\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\nindex f9b36e4..612a1cb 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\n@@ -52,6 +52,10 @@ public class ByteValueParser extends FieldParser<ByteValue> {\n \t\tfor (int i = startPos; i < limit; i++) {\n \n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((byte) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\nindex 947fdfe..086c1f5 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\n@@ -23,35 +23,39 @@ package org.apache.flink.types.parser;\n  * Parses a text field into a Double.\n  */\n public class DoubleParser extends FieldParser<Double> {\n-\t\n+\n \tprivate static final Double DOUBLE_INSTANCE = Double.valueOf(0.0);\n-\t\n+\n \tprivate double result;\n-\t\n+\n \t@Override\n \tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Double reusable) {\n \t\tint i = startPos;\n \n-\t\tfinal int delimLimit = limit-delimiter.length+1;\n-\t\t\n+\t\tfinal int delimLimit = limit - delimiter.length + 1;\n+\n \t\twhile (i < limit) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\ti++;\n \t\t}\n-\t\t\n-\t\tString str = new String(bytes, startPos, i-startPos);\n+\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tthis.result = Double.parseDouble(str);\n \t\t\treturn (i == limit) ? limit : i + delimiter.length;\n-\t\t}\n-\t\tcatch (NumberFormatException e) {\n+\t\t} catch (NumberFormatException e) {\n \t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\n \t\t\treturn -1;\n \t\t}\n \t}\n-\t\n+\n \t@Override\n \tpublic Double createValue() {\n \t\treturn DOUBLE_INSTANCE;\n@@ -61,35 +65,35 @@ public class DoubleParser extends FieldParser<Double> {\n \tpublic Double getLastResult() {\n \t\treturn Double.valueOf(this.result);\n \t}\n-\t\n+\n \t/**\n-\t * Static utility to parse a field of type double from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type double from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n-\t * \n-\t * @param bytes The bytes containing the text data that should be parsed.\n+\t *\n+\t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n-\t * @param length The length of the byte sequence (counting from the offset).\n-\t * \n+\t * @param length   The length of the byte sequence (counting from the offset).\n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final double parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n-\t\n+\n \t/**\n-\t * Static utility to parse a field of type double from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type double from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n-\t * \n-\t * @param bytes The bytes containing the text data that should be parsed.\n-\t * @param startPos The offset to start the parsing.\n-\t * @param length The length of the byte sequence (counting from the offset).\n+\t *\n+\t * @param bytes     The bytes containing the text data that should be parsed.\n+\t * @param startPos  The offset to start the parsing.\n+\t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {\n \t\tif (length <= 0) {\n@@ -97,12 +101,17 @@ public class DoubleParser extends FieldParser<Double> {\n \t\t}\n \t\tint i = 0;\n \t\tfinal byte delByte = (byte) delimiter;\n-\t\t\n+\n \t\twhile (i < length && bytes[i] != delByte) {\n \t\t\ti++;\n \t\t}\n-\t\t\n-\t\tString str = new String(bytes, startPos, i);\n+\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tthrow new NumberFormatException(\"There is leading or trailing whitespace in the \" +\n+\t\t\t\t\"numeric field: \" + str);\n+\t\t}\n \t\treturn Double.parseDouble(str);\n \t}\n }\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\nindex e225c1f..7751831 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\n@@ -33,7 +33,7 @@ public class DoubleValueParser extends FieldParser<DoubleValue> {\n \t\t\n \t\tint i = startPos;\n \n-\t\tfinal int delimLimit = limit-delimiter.length+1;\n+\t\tfinal int delimLimit = limit - delimiter.length + 1;\n \n \t\twhile (i < limit) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n@@ -42,7 +42,11 @@ public class DoubleValueParser extends FieldParser<DoubleValue> {\n \t\t\ti++;\n \t\t}\n \t\t\n-\t\tString str = new String(bytes, startPos, i-startPos);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tdouble value = Double.parseDouble(str);\n \t\t\treusable.setValue(value);\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\nindex 33697fd..55e9915 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\n@@ -64,7 +64,13 @@ public abstract class FieldParser<T> {\n \t\tUNTERMINATED_QUOTED_STRING,\n \n \t\t/** The parser found characters between the end of the quoted string and the delimiter. */\n-\t\tUNQUOTED_CHARS_AFTER_QUOTED_STRING\n+\t\tUNQUOTED_CHARS_AFTER_QUOTED_STRING,\n+\t\t\n+\t\t/** The string is empty. */\n+\t\tEMPTY_STRING,\n+\n+\t\t/** There is whitespace in a numeric field. */\n+\t\tWHITESPACE_IN_NUMERIC_FIELD\n \t}\n \t\n \tprivate ParseErrorState errorState = ParseErrorState.NONE;\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\nindex 7d166c7..be98aa1 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\n@@ -23,15 +23,16 @@ package org.apache.flink.types.parser;\n  * Parses a text field into a {@link Float}.\n  */\n public class FloatParser extends FieldParser<Float> {\n-\t\n+\n \tprivate float result;\n \t\n \t@Override\n-\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float reusable) {\n-\t\t\n+\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float \n+\t\treusable) {\n+\n \t\tint i = startPos;\n \n-\t\tfinal int delimLimit = limit-delimiter.length+1;\n+\t\tfinal int delimLimit = limit - delimiter.length + 1;\n \n \t\twhile (i < limit) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n@@ -39,18 +40,23 @@ public class FloatParser extends FieldParser<Float> {\n \t\t\t}\n \t\t\ti++;\n \t\t}\n-\t\t\n-\t\tString str = new String(bytes, startPos, i-startPos);\n+\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n \t\ttry {\n \t\t\tthis.result = Float.parseFloat(str);\n-\t\t\treturn (i == limit) ? limit : i+ delimiter.length;\n-\t\t}\n-\t\tcatch (NumberFormatException e) {\n+\t\t\treturn (i == limit) ? limit : i + delimiter.length;\n+\t\t} catch (NumberFormatException e) {\n \t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\n \t\t\treturn -1;\n \t\t}\n \t}\n-\t\n+\n \t@Override\n \tpublic Float createValue() {\n \t\treturn Float.MIN_VALUE;\n@@ -60,35 +66,35 @@ public class FloatParser extends FieldParser<Float> {\n \tpublic Float getLastResult() {\n \t\treturn Float.valueOf(this.result);\n \t}\n-\t\n+\n \t/**\n-\t * Static utility to parse a field of type float from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type float from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n-\t * \n-\t * @param bytes The bytes containing the text data that should be parsed.\n+\t *\n+\t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n-\t * @param length The length of the byte sequence (counting from the offset).\n-\t * \n+\t * @param length   The length of the byte sequence (counting from the offset).\n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final float parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n-\t\n+\n \t/**\n-\t * Static utility to parse a field of type float from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type float from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n-\t * \n-\t * @param bytes The bytes containing the text data that should be parsed.\n-\t * @param startPos The offset to start the parsing.\n-\t * @param length The length of the byte sequence (counting from the offset).\n+\t *\n+\t * @param bytes     The bytes containing the text data that should be parsed.\n+\t * @param startPos  The offset to start the parsing.\n+\t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {\n \t\tif (length <= 0) {\n@@ -96,12 +102,17 @@ public class FloatParser extends FieldParser<Float> {\n \t\t}\n \t\tint i = 0;\n \t\tfinal byte delByte = (byte) delimiter;\n-\t\t\n+\n \t\twhile (i < length && bytes[i] != delByte) {\n \t\t\ti++;\n \t\t}\n \t\t\n-\t\tString str = new String(bytes, startPos, i);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tthrow new NumberFormatException(\"There is leading or trailing whitespace in the \" +\n+\t\t\t\t\"numeric field: \" + str);\n+\t\t}\n+\t\tint len = str.length();\n \t\treturn Float.parseFloat(str);\n \t}\n }\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\nindex af16d4c..e8caac2 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\n@@ -33,7 +33,7 @@ public class FloatValueParser extends FieldParser<FloatValue> {\n \t\t\n \t\tint i = startPos;\n \n-\t\tfinal int delimLimit = limit-delimiter.length+1;\n+\t\tfinal int delimLimit = limit - delimiter.length + 1;\n \n \t\twhile (i < limit) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n@@ -42,7 +42,11 @@ public class FloatValueParser extends FieldParser<FloatValue> {\n \t\t\ti++;\n \t\t}\n \t\t\n-\t\tString str = new String(bytes, startPos, i-startPos);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tfloat value = Float.parseFloat(str);\n \t\t\treusable.setValue(value);\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\nindex c871f4a..dcd2ec2 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\n@@ -25,32 +25,38 @@ package org.apache.flink.types.parser;\n  * The parser does not check for the maximum value.\n  */\n public class IntParser extends FieldParser<Integer> {\n-\t\n+\n \tprivate static final long OVERFLOW_BOUND = 0x7fffffffL;\n \tprivate static final long UNDERFLOW_BOUND = 0x80000000L;\n \n \tprivate int result;\n-\t\n+\n \t@Override\n-\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {\n+\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer \n+\t\treusable) {\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n-\t\tfinal int delimLimit = limit-delimiter.length+1;\n+\t\tfinal int delimLimit = limit - delimiter.length + 1;\n \n \t\tif (bytes[startPos] == '-') {\n \t\t\tneg = true;\n \t\t\tstartPos++;\n-\t\t\t\n+\n \t\t\t// check for empty field with only the sign\n-\t\t\tif (startPos == limit || ( startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n+\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, \n+\t\t\t\tdelimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (int) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -60,17 +66,17 @@ public class IntParser extends FieldParser<Integer> {\n \t\t\t}\n \t\t\tval *= 10;\n \t\t\tval += bytes[i] - 48;\n-\t\t\t\n+\n \t\t\tif (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tthis.result = (int) (neg ? -val : val);\n \t\treturn limit;\n \t}\n-\t\n+\n \t@Override\n \tpublic Integer createValue() {\n \t\treturn Integer.MIN_VALUE;\n@@ -80,40 +86,37 @@ public class IntParser extends FieldParser<Integer> {\n \tpublic Integer getLastResult() {\n \t\treturn Integer.valueOf(this.result);\n \t}\n-\t\n+\n \t/**\n-\t * Static utility to parse a field of type int from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type int from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n-\t * \n-\t * @param bytes The bytes containing the text data that should be parsed.\n+\t *\n+\t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n-\t * @param length The length of the byte sequence (counting from the offset).\n-\t * \n+\t * @param length   The length of the byte sequence (counting from the offset).\n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final int parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n-\t\n+\n \t/**\n-\t * Static utility to parse a field of type int from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type int from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n-\t * \n-\t * @param bytes The bytes containing the text data that should be parsed.\n-\t * @param startPos The offset to start the parsing.\n-\t * @param length The length of the byte sequence (counting from the offset).\n+\t *\n+\t * @param bytes     The bytes containing the text data that should be parsed.\n+\t * @param startPos  The offset to start the parsing.\n+\t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -125,17 +128,17 @@ public class IntParser extends FieldParser<Integer> {\n \t\t\t\tthrow new NumberFormatException(\"Orphaned minus sign.\");\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (int) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\n \t\t\t}\n \t\t\tval *= 10;\n \t\t\tval += bytes[startPos] - 48;\n-\t\t\t\n+\n \t\t\tif (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n \t\t\t\tthrow new NumberFormatException(\"Value overflow/underflow\");\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\nindex 8cb8176..abd8615 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\n@@ -54,6 +54,10 @@ public class IntValueParser extends FieldParser<IntValue> {\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((int) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\nindex af17f15..bb6c7c9 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\n@@ -24,9 +24,9 @@ package org.apache.flink.types.parser;\n  * Only characters '1' to '0' and '-' are allowed.\n  */\n public class LongParser extends FieldParser<Long> {\n-\t\n+\n \tprivate long result;\n-\t\n+\n \t@Override\n \tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Long reusable) {\n \t\tlong val = 0;\n@@ -37,16 +37,20 @@ public class LongParser extends FieldParser<Long> {\n \t\tif (bytes[startPos] == '-') {\n \t\t\tneg = true;\n \t\t\tstartPos++;\n-\t\t\t\n+\n \t\t\t// check for empty field with only the sign\n \t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = neg ? -val : val;\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -56,15 +60,15 @@ public class LongParser extends FieldParser<Long> {\n \t\t\t}\n \t\t\tval *= 10;\n \t\t\tval += bytes[i] - 48;\n-\t\t\t\n+\n \t\t\t// check for overflow / underflow\n \t\t\tif (val < 0) {\n \t\t\t\t// this is an overflow/underflow, unless we hit exactly the Long.MIN_VALUE\n \t\t\t\tif (neg && val == Long.MIN_VALUE) {\n \t\t\t\t\tthis.result = Long.MIN_VALUE;\n-\t\t\t\t\t\n+\n \t\t\t\t\tif (i+1 >= limit) {\n-\t\t\t\t\t\treturn limit; \n+\t\t\t\t\t\treturn limit;\n \t\t\t\t\t} else if (i+1 < delimLimit && delimiterNext(bytes, i+1, delimiter)) {\n \t\t\t\t\t\treturn i + 1 + delimiter.length;\n \t\t\t\t\t} else {\n@@ -78,57 +82,54 @@ public class LongParser extends FieldParser<Long> {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tthis.result = neg ? -val : val;\n \t\treturn limit;\n \t}\n-\t\n+\n \t@Override\n \tpublic Long createValue() {\n \t\treturn Long.MIN_VALUE;\n \t}\n-\t\n+\n \t@Override\n \tpublic Long getLastResult() {\n \t\treturn Long.valueOf(this.result);\n \t}\n-\t\n+\n \t/**\n \t * Static utility to parse a field of type long from a byte sequence that represents text characters\n \t * (such as when read from a file stream).\n-\t * \n+\t *\n \t * @param bytes The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length The length of the byte sequence (counting from the offset).\n-\t * \n+\t *\n \t * @return The parsed value.\n-\t * \n+\t *\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final long parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n-\t\n+\n \t/**\n \t * Static utility to parse a field of type long from a byte sequence that represents text characters\n \t * (such as when read from a file stream).\n-\t * \n+\t *\n \t * @param bytes The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n+\t *\n \t * @return The parsed value.\n-\t * \n+\t *\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n-\t\t\n+\n \t\tif (bytes[startPos] == '-') {\n \t\t\tneg = true;\n \t\t\tstartPos++;\n@@ -137,17 +138,17 @@ public class LongParser extends FieldParser<Long> {\n \t\t\t\tthrow new NumberFormatException(\"Orphaned minus sign.\");\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn neg ? -val : val;\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\n \t\t\t}\n \t\t\tval *= 10;\n \t\t\tval += bytes[startPos] - 48;\n-\t\t\t\n+\n \t\t\t// check for overflow / underflow\n \t\t\tif (val < 0) {\n \t\t\t\t// this is an overflow/underflow, unless we hit exactly the Long.MIN_VALUE\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\nindex 8b697cc..a99a86e 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\n@@ -51,6 +51,10 @@ public class LongValueParser extends FieldParser<LongValue> {\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue(neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\nindex a6f9898..6e04d60 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\n@@ -25,10 +25,10 @@ package org.apache.flink.types.parser;\n  * The parser does not check for the maximum value.\n  */\n public class ShortParser extends FieldParser<Short> {\n-\t\n+\n \tprivate static final int OVERFLOW_BOUND = 0x7fff;\n \tprivate static final int UNDERFLOW_BOUND = 0x8000;\n-\t\n+\n \tprivate short result;\n \n \t@Override\n@@ -37,20 +37,24 @@ public class ShortParser extends FieldParser<Short> {\n \t\tboolean neg = false;\n \n \t\tfinal int delimLimit = limit-delimiter.length+1;\n-\t\t\n+\n \t\tif (bytes[startPos] == '-') {\n \t\t\tneg = true;\n \t\t\tstartPos++;\n-\t\t\t\n+\n \t\t\t// check for empty field with only the sign\n \t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (short) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -60,17 +64,17 @@ public class ShortParser extends FieldParser<Short> {\n \t\t\t}\n \t\t\tval *= 10;\n \t\t\tval += bytes[i] - 48;\n-\t\t\t\n+\n \t\t\tif (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tthis.result = (short) (neg ? -val : val);\n \t\treturn limit;\n \t}\n-\t\n+\n \t@Override\n \tpublic Short createValue() {\n \t\treturn Short.MIN_VALUE;\n@@ -80,43 +84,40 @@ public class ShortParser extends FieldParser<Short> {\n \tpublic Short getLastResult() {\n \t\treturn Short.valueOf(this.result);\n \t}\n-\t\n+\n \t/**\n \t * Static utility to parse a field of type short from a byte sequence that represents text characters\n \t * (such as when read from a file stream).\n-\t * \n+\t *\n \t * @param bytes The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length The length of the byte sequence (counting from the offset).\n-\t * \n+\t *\n \t * @return The parsed value.\n-\t * \n+\t *\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final short parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n-\t\n+\n \t/**\n \t * Static utility to parse a field of type short from a byte sequence that represents text characters\n \t * (such as when read from a file stream).\n-\t * \n+\t *\n \t * @param bytes The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n+\t *\n \t * @return The parsed value.\n-\t * \n+\t *\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final short parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n-\t\t\n+\n \t\tif (bytes[startPos] == '-') {\n \t\t\tneg = true;\n \t\t\tstartPos++;\n@@ -125,17 +126,17 @@ public class ShortParser extends FieldParser<Short> {\n \t\t\t\tthrow new NumberFormatException(\"Orphaned minus sign.\");\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (short) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\n \t\t\t}\n \t\t\tval *= 10;\n \t\t\tval += bytes[startPos] - 48;\n-\t\t\t\n+\n \t\t\tif (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n \t\t\t\tthrow new NumberFormatException(\"Value overflow/underflow\");\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\nindex f5168cc..4289d1a 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\n@@ -54,6 +54,10 @@ public class ShortValueParser extends FieldParser<ShortValue> {\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((short) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n", "nb_test": 835, "nb_skipped": 0, "fix_commit": "39d526e6", "id": "1820"}