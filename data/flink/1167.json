{
  "files": 3, 
  "singleLine": false, 
  "nb_error": 0, 
  "failing_tests": [
    "IterationCompilerTest.testIterationWithUnionRoot:106 An error occurred while translating the optimized plan to a nephele JobGraph: Error translating node 'Union \"Union\" : UNION [[ GlobalProperties [partitioning=RANDOM] ]] [[ LocalProperties [ordering=null, grouped=null, unique=null] ]]': null", 
    "IterationCompilerTest.testWorksetIterationWithUnionRoot:141 An error occurred while translating the optimized plan to a nephele JobGraph: Error translating node 'Union \"Union\" : UNION [[ GlobalProperties [partitioning=RANDOM] ]] [[ LocalProperties [ordering=null, grouped=null, unique=null] ]]': null"
  ], 
  "nb_test": 93, 
  "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\nindex a5f8026..d3f0fbb 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\n@@ -132,7 +132,7 @@ public class BulkIterationNode extends SingleInputNode implements IterationNode\n \t\t// check if the root of the step function has the same DOP as the iteration\n \t\t// or if the steo function has any operator at all\n \t\tif (nextPartialSolution.getDegreeOfParallelism() != getDegreeOfParallelism() ||\n-\t\t\tnextPartialSolution == partialSolution)\n+\t\t\tnextPartialSolution == partialSolution || nextPartialSolution instanceof BinaryUnionNode)\n \t\t{\n \t\t\t// add a no-op to the root to express the re-partitioning\n \t\t\tNoOpNode noop = new NoOpNode();\ndiff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\nindex 7638cca..b6ae34e 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\n@@ -160,7 +160,7 @@ public class WorksetIterationNode extends TwoInputNode implements IterationNode\n \t\t\n \t\t// there needs to be at least one node in the workset path, so\n \t\t// if the next workset is equal to the workset, we need to inject a no-op node\n-\t\tif (nextWorkset == worksetNode) {\n+\t\tif (nextWorkset == worksetNode || nextWorkset instanceof BinaryUnionNode) {\n \t\t\tNoOpNode noop = new NoOpNode();\n \t\t\tnoop.setDegreeOfParallelism(getDegreeOfParallelism());\n \ndiff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java b/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\nindex 00e2bc2..60500b8 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\n@@ -16,7 +16,6 @@\n  * limitations under the License.\n  */\n \n-\n package org.apache.flink.compiler.plandump;\n \n import java.io.File;\n@@ -26,7 +25,6 @@ import java.io.PrintWriter;\n import java.io.StringWriter;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n@@ -47,7 +45,6 @@ import org.apache.flink.compiler.dataproperties.GlobalProperties;\n import org.apache.flink.compiler.dataproperties.LocalProperties;\n import org.apache.flink.compiler.plan.BulkIterationPlanNode;\n import org.apache.flink.compiler.plan.Channel;\n-import org.apache.flink.compiler.plan.NAryUnionPlanNode;\n import org.apache.flink.compiler.plan.OptimizedPlan;\n import org.apache.flink.compiler.plan.PlanNode;\n import org.apache.flink.compiler.plan.SingleInputPlanNode;\n@@ -265,121 +262,104 @@ public class PlanJSONDumpGenerator {\n \t\tif (inConns != null && inConns.hasNext()) {\n \t\t\t// start predecessor list\n \t\t\twriter.print(\",\\n\\t\\t\\\"predecessors\\\": [\");\n-\t\t\tint connNum = 0;\n \t\t\tint inputNum = 0;\n \t\t\t\n \t\t\twhile (inConns.hasNext()) {\n-\t\t\t\tfinal DumpableConnection<?> conn = inConns.next();\n-\t\t\t\t\n-\t\t\t\tfinal Collection<DumpableConnection<?>> inConnsForInput;\n-\t\t\t\tif (conn.getSource() instanceof NAryUnionPlanNode) {\n-\t\t\t\t\tinConnsForInput = new ArrayList<DumpableConnection<?>>();\n+\t\t\t\tfinal DumpableConnection<?> inConn = inConns.next();\n+\t\t\t\tfinal DumpableNode<?> source = inConn.getSource();\n+\t\t\t\twriter.print(inputNum == 0 ? \"\\n\" : \",\\n\");\n+\t\t\t\tif (inputNum == 0) {\n+\t\t\t\t\tchild1name += child1name.length() > 0 ? \", \" : \"\"; \n+\t\t\t\t\tchild1name += source.getOptimizerNode().getPactContract().getName();\n+\t\t\t\t} else if (inputNum == 1) {\n+\t\t\t\t\tchild2name += child2name.length() > 0 ? \", \" : \"\"; \n+\t\t\t\t\tchild2name = source.getOptimizerNode().getPactContract().getName();\n+\t\t\t\t}\n+\n+\t\t\t\t// output predecessor id\n+\t\t\t\twriter.print(\"\\t\\t\\t{\\\"id\\\": \" + this.nodeIds.get(source));\n+\n+\t\t\t\t// output connection side\n+\t\t\t\tif (inConns.hasNext() || inputNum > 0) {\n+\t\t\t\t\twriter.print(\", \\\"side\\\": \\\"\" + (inputNum == 0 ? \"first\" : \"second\") + \"\\\"\");\n+\t\t\t\t}\n+\t\t\t\t// output shipping strategy and channel type\n+\t\t\t\tfinal Channel channel = (inConn instanceof Channel) ? (Channel) inConn : null; \n+\t\t\t\tfinal ShipStrategyType shipType = channel != null ? channel.getShipStrategy() :\n+\t\t\t\t\t\t((PactConnection) inConn).getShipStrategy();\n \t\t\t\t\t\n-\t\t\t\t\tfor (DumpableConnection<?> inputOfUnion : conn.getSource().getDumpableInputs()) {\n-\t\t\t\t\t\tinConnsForInput.add(inputOfUnion);\n+\t\t\t\tString shipStrategy = null;\n+\t\t\t\tif (shipType != null) {\n+\t\t\t\t\tswitch (shipType) {\n+\t\t\t\t\tcase NONE:\n+\t\t\t\t\t\t// nothing\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase FORWARD:\n+\t\t\t\t\t\tshipStrategy = \"Forward\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase BROADCAST:\n+\t\t\t\t\t\tshipStrategy = \"Broadcast\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase PARTITION_HASH:\n+\t\t\t\t\t\tshipStrategy = \"Hash Partition\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase PARTITION_RANGE:\n+\t\t\t\t\t\tshipStrategy = \"Range Partition\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase PARTITION_RANDOM:\n+\t\t\t\t\t\tshipStrategy = \"Redistribute\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase PARTITION_FORCED_REBALANCE:\n+\t\t\t\t\t\tshipStrategy = \"Rebalance\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new CompilerException(\"Unknown ship strategy '\" + inConn.getShipStrategy().name()\n+\t\t\t\t\t\t\t+ \"' in JSON generator.\");\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tinConnsForInput = Collections.<DumpableConnection<?>>singleton(conn);\n+\t\t\t\t\n+\t\t\t\tif (channel != null && channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {\n+\t\t\t\t\tshipStrategy += \" on \" + (channel.getShipStrategySortOrder() == null ?\n+\t\t\t\t\t\t\tchannel.getShipStrategyKeys().toString() :\n+\t\t\t\t\t\t\tUtils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString());\n+\t\t\t\t}\n+\n+\t\t\t\tif (shipStrategy != null) {\n+\t\t\t\t\twriter.print(\", \\\"ship_strategy\\\": \\\"\" + shipStrategy + \"\\\"\");\n \t\t\t\t}\n \t\t\t\t\n-\t\t\t\tfor (DumpableConnection<?> inConn : inConnsForInput) {\n-\t\t\t\t\tfinal DumpableNode<?> source = inConn.getSource();\n-\t\t\t\t\twriter.print(connNum == 0 ? \"\\n\" : \",\\n\");\n-\t\t\t\t\tif (connNum == 0) {\n-\t\t\t\t\t\tchild1name += child1name.length() > 0 ? \", \" : \"\"; \n-\t\t\t\t\t\tchild1name += source.getOptimizerNode().getPactContract().getName();\n-\t\t\t\t\t} else if (connNum == 1) {\n-\t\t\t\t\t\tchild2name += child2name.length() > 0 ? \", \" : \"\"; \n-\t\t\t\t\t\tchild2name = source.getOptimizerNode().getPactContract().getName();\n-\t\t\t\t\t}\n-\t\n-\t\t\t\t\t// output predecessor id\n-\t\t\t\t\twriter.print(\"\\t\\t\\t{\\\"id\\\": \" + this.nodeIds.get(source));\n-\t\n-\t\t\t\t\t// output connection side\n-\t\t\t\t\tif (inConns.hasNext() || inputNum > 0) {\n-\t\t\t\t\t\twriter.print(\", \\\"side\\\": \\\"\" + (inputNum == 0 ? \"first\" : \"second\") + \"\\\"\");\n-\t\t\t\t\t}\n-\t\t\t\t\t// output shipping strategy and channel type\n-\t\t\t\t\tfinal Channel channel = (inConn instanceof Channel) ? (Channel) inConn : null; \n-\t\t\t\t\tfinal ShipStrategyType shipType = channel != null ? channel.getShipStrategy() :\n-\t\t\t\t\t\t\t((PactConnection) inConn).getShipStrategy();\n-\t\t\t\t\t\t\n-\t\t\t\t\tString shipStrategy = null;\n-\t\t\t\t\tif (shipType != null) {\n-\t\t\t\t\t\tswitch (shipType) {\n-\t\t\t\t\t\tcase NONE:\n-\t\t\t\t\t\t\t// nothing\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FORWARD:\n-\t\t\t\t\t\t\tshipStrategy = \"Forward\";\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase BROADCAST:\n-\t\t\t\t\t\t\tshipStrategy = \"Broadcast\";\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase PARTITION_HASH:\n-\t\t\t\t\t\t\tshipStrategy = \"Hash Partition\";\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase PARTITION_RANGE:\n-\t\t\t\t\t\t\tshipStrategy = \"Range Partition\";\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase PARTITION_RANDOM:\n-\t\t\t\t\t\t\tshipStrategy = \"Redistribute\";\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase PARTITION_FORCED_REBALANCE:\n-\t\t\t\t\t\t\tshipStrategy = \"Rebalance\";\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tthrow new CompilerException(\"Unknown ship strategy '\" + conn.getShipStrategy().name()\n-\t\t\t\t\t\t\t\t+ \"' in JSON generator.\");\n-\t\t\t\t\t\t}\n+\t\t\t\tif (channel != null) {\n+\t\t\t\t\tString localStrategy = null;\n+\t\t\t\t\tswitch (channel.getLocalStrategy()) {\n+\t\t\t\t\tcase NONE:\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase SORT:\n+\t\t\t\t\t\tlocalStrategy = \"Sort\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase COMBININGSORT:\n+\t\t\t\t\t\tlocalStrategy = \"Sort (combining)\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new CompilerException(\"Unknown local strategy \" + channel.getLocalStrategy().name());\n \t\t\t\t\t}\n \t\t\t\t\t\n-\t\t\t\t\tif (channel != null && channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {\n-\t\t\t\t\t\tshipStrategy += \" on \" + (channel.getShipStrategySortOrder() == null ?\n-\t\t\t\t\t\t\t\tchannel.getShipStrategyKeys().toString() :\n-\t\t\t\t\t\t\t\tUtils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString());\n-\t\t\t\t\t}\n-\t\n-\t\t\t\t\tif (shipStrategy != null) {\n-\t\t\t\t\t\twriter.print(\", \\\"ship_strategy\\\": \\\"\" + shipStrategy + \"\\\"\");\n+\t\t\t\t\tif (channel != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {\n+\t\t\t\t\t\tlocalStrategy += \" on \" + (channel.getLocalStrategySortOrder() == null ?\n+\t\t\t\t\t\t\t\tchannel.getLocalStrategyKeys().toString() :\n+\t\t\t\t\t\t\t\tUtils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString());\n \t\t\t\t\t}\n \t\t\t\t\t\n-\t\t\t\t\tif (channel != null) {\n-\t\t\t\t\t\tString localStrategy = null;\n-\t\t\t\t\t\tswitch (channel.getLocalStrategy()) {\n-\t\t\t\t\t\tcase NONE:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase SORT:\n-\t\t\t\t\t\t\tlocalStrategy = \"Sort\";\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase COMBININGSORT:\n-\t\t\t\t\t\t\tlocalStrategy = \"Sort (combining)\";\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tthrow new CompilerException(\"Unknown local strategy \" + channel.getLocalStrategy().name());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\t\n-\t\t\t\t\t\tif (channel != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {\n-\t\t\t\t\t\t\tlocalStrategy += \" on \" + (channel.getLocalStrategySortOrder() == null ?\n-\t\t\t\t\t\t\t\t\tchannel.getLocalStrategyKeys().toString() :\n-\t\t\t\t\t\t\t\t\tUtils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\t\n-\t\t\t\t\t\tif (localStrategy != null) {\n-\t\t\t\t\t\t\twriter.print(\", \\\"local_strategy\\\": \\\"\" + localStrategy + \"\\\"\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\t\n-\t\t\t\t\t\tif (channel != null && channel.getTempMode() != TempMode.NONE) {\n-\t\t\t\t\t\t\tString tempMode = channel.getTempMode().toString();\n-\t\t\t\t\t\t\twriter.print(\", \\\"temp_mode\\\": \\\"\" + tempMode + \"\\\"\");\n-\t\t\t\t\t\t}\n+\t\t\t\t\tif (localStrategy != null) {\n+\t\t\t\t\t\twriter.print(\", \\\"local_strategy\\\": \\\"\" + localStrategy + \"\\\"\");\n \t\t\t\t\t}\n \t\t\t\t\t\n-\t\t\t\t\twriter.print('}');\n-\t\t\t\t\tconnNum++;\n+\t\t\t\t\tif (channel != null && channel.getTempMode() != TempMode.NONE) {\n+\t\t\t\t\t\tString tempMode = channel.getTempMode().toString();\n+\t\t\t\t\t\twriter.print(\", \\\"temp_mode\\\": \\\"\" + tempMode + \"\\\"\");\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\t\n+\t\t\t\twriter.print('}');\n \t\t\t\tinputNum++;\n \t\t\t}\n \t\t\t// finish predecessors\n", 
  "project": "flink", 
  "linesAdd": 85, 
  "nb_skipped": 0, 
  "fix_commit": "259f10c0", 
  "nb_failure": 2, 
  "id": "1167", 
  "linesRem": 105
}