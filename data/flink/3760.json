{
  "files": 1, 
  "singleLine": false, 
  "nb_error": 1, 
  "failing_tests": [
    "ValueStateDescriptorTest.testVeryLargeDefaultValue:126 \u00bb Runtime Read size doe..."
  ], 
  "nb_test": 1802, 
  "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java b/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\nindex 10ac5ba..243ebcd 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\n@@ -61,12 +61,12 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \t/** The type information describing the value type. Only used to lazily create the serializer\n \t * and dropped during serialization */\n \tprivate transient TypeInformation<T> typeInfo;\n-\t\n+\n \t// ------------------------------------------------------------------------\n-\t\n+\n \t/**\n \t * Create a new {@code StateDescriptor} with the given name and the given type serializer.\n-\t * \n+\t *\n \t * @param name The name of the {@code StateDescriptor}.\n \t * @param serializer The type serializer for the values in the state.\n \t * @param defaultValue The default value that will be set when requesting state without setting\n@@ -94,7 +94,7 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \n \t/**\n \t * Create a new {@code StateDescriptor} with the given name and the given type information.\n-\t * \n+\t *\n \t * <p>If this constructor fails (because it is not possible to describe the type via a class),\n \t * consider using the {@link #StateDescriptor(String, TypeInformation, Object)} constructor.\n \t *\n@@ -106,7 +106,7 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \tprotected StateDescriptor(String name, Class<T> type, T defaultValue) {\n \t\tthis.name = requireNonNull(name, \"name must not be null\");\n \t\trequireNonNull(type, \"type class must not be null\");\n-\t\t\n+\n \t\ttry {\n \t\t\tthis.typeInfo = TypeExtractor.createTypeInfo(type);\n \t\t} catch (Exception e) {\n@@ -117,7 +117,7 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \t}\n \n \t// ------------------------------------------------------------------------\n-\t\n+\n \t/**\n \t * Returns the name of this {@code StateDescriptor}.\n \t */\n@@ -152,21 +152,21 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \t\t\tthrow new IllegalStateException(\"Serializer not yet initialized.\");\n \t\t}\n \t}\n-\t\n+\n \t/**\n \t * Creates a new {@link State} on the given {@link StateBackend}.\n \t *\n \t * @param stateBackend The {@code StateBackend} on which to create the {@link State}.\n \t */\n \tpublic abstract S bind(StateBackend stateBackend) throws Exception;\n-\t\n+\n \t// ------------------------------------------------------------------------\n \n \t/**\n \t * Checks whether the serializer has been initialized. Serializer initialization is lazy,\n \t * to allow parametrization of serializers with an {@link ExecutionConfig} via\n \t * {@link #initializeSerializerUnlessSet(ExecutionConfig)}.\n-\t * \n+\t *\n \t * @return True if the serializers have been initialized, false otherwise.\n \t */\n \tpublic boolean isSerializerInitialized() {\n@@ -175,7 +175,7 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \n \t/**\n \t * Initializes the serializer, unless it has been initialized before.\n-\t * \n+\t *\n \t * @param executionConfig The execution config to use when creating the serializer.\n \t */\n \tpublic void initializeSerializerUnlessSet(ExecutionConfig executionConfig) {\n@@ -188,7 +188,7 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \t\t\t}\n \t\t}\n \t}\n-\t\n+\n \t/**\n \t * This method should be called by subclasses prior to serialization. Because the TypeInformation is\n \t * not always serializable, it is 'transient' and dropped during serialization. Hence, the descriptor\n@@ -204,7 +204,7 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \t\t\t}\n \t\t}\n \t}\n-\t\n+\n \t// ------------------------------------------------------------------------\n \t//  Standard Utils\n \t// ------------------------------------------------------------------------\n@@ -230,7 +230,7 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn getClass().getSimpleName() + \n+\t\treturn getClass().getSimpleName() +\n \t\t\t\t\"{name=\" + name +\n \t\t\t\t\", defaultValue=\" + defaultValue +\n \t\t\t\t\", serializer=\" + serializer +\n@@ -257,7 +257,7 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \t\t\tout.writeBoolean(true);\n \n \t\t\tbyte[] serializedDefaultValue;\n-\t\t\ttry (ByteArrayOutputStream baos = new ByteArrayOutputStream(); \n+\t\t\ttry (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n \t\t\t\t\tDataOutputViewStreamWrapper outView = new DataOutputViewStreamWrapper(baos))\n \t\t\t{\n \t\t\t\tTypeSerializer<T> duplicateSerializer = serializer.duplicate();\n@@ -284,12 +284,10 @@ public abstract class StateDescriptor<S extends State, T> implements Serializabl\n \t\tboolean hasDefaultValue = in.readBoolean();\n \t\tif (hasDefaultValue) {\n \t\t\tint size = in.readInt();\n+\n \t\t\tbyte[] buffer = new byte[size];\n-\t\t\tint bytesRead = in.read(buffer);\n \n-\t\t\tif (bytesRead != size) {\n-\t\t\t\tthrow new RuntimeException(\"Read size does not match expected size.\");\n-\t\t\t}\n+\t\t\tin.readFully(buffer);\n \n \t\t\ttry (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);\n \t\t\t\t\tDataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais))\n", 
  "project": "flink", 
  "linesAdd": 16, 
  "nb_skipped": 0, 
  "fix_commit": "494212b3", 
  "nb_failure": 0, 
  "id": "3760", 
  "linesRem": 18
}