{"files": 4, "singleLine": false, "nb_error": 0, "failing_tests": ["testMissedEndEvent(org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest)", "testMissedEndEvent(org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest)"], "nb_test": 2152, "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\nindex 935bb8b..6ee9bd5 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n@@ -271,8 +271,16 @@ public class AdamsBashforthIntegrator extends AdamsIntegrator {\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n-                            loop = false;\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n+                            loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\n                             hNew = dt;\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\nindex 27ade7b..e0e2f0d 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n@@ -289,8 +289,16 @@ public class AdamsMoultonIntegrator extends AdamsIntegrator {\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n-                            loop = false;\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n+                            loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\n                             hNew = dt;\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 34b3dc1..e03be9e 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -292,8 +292,16 @@ public abstract class EmbeddedRungeKuttaIntegrator\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // rejecting the step would lead to a too small next step, we accept it\n-                  loop = false;\n+                  // we cannot simply truncate the step, reject the current computation\n+                  // and let the loop compute another state with the truncated step.\n+                  // it is so small (much probably exactly 0 due to limited accuracy)\n+                  // that the code above would fail handling it.\n+                  // So we set up an artificial 0 size step by copying states\n+                  interpolator.storeTime(stepStart);\n+                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                  hNew     = 0;\n+                  stepSize = 0;\n+                  loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex 3227b98..b61b0b1 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -172,8 +172,15 @@ public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // rejecting the step would lead to a too small next step, we accept it\n-                loop = false;\n+                // we cannot simply truncate the step, reject the current computation\n+                // and let the loop compute another state with the truncated step.\n+                // it is so small (much probably exactly 0 due to limited accuracy)\n+                // that the code above would fail handling it.\n+                // So we set up an artificial 0 size step by copying states\n+                interpolator.storeTime(stepStart);\n+                System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                stepSize = 0;\n+                loop     = false;\n             } else {\n                 // reject the step to match exactly the next switch time\n                 stepSize = dt;\n", "project": "commons-math", "linesAdd": 39, "nb_skipped": 0, "fix_commit": "061f5017", "nb_failure": 2, "id": "358", "linesRem": 8}