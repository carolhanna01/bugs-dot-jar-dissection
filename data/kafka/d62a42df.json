{
  "project": "kafka",
  "jira_id": "14265",
  "commit": "d62a42df",
  "classification": {
    "singleLine": false
  },
  "patch": "diff --git a/metadata/src/main/java/org/apache/kafka/metadata/authorizer/StandardAuthorizerData.java b/metadata/src/main/java/org/apache/kafka/metadata/authorizer/StandardAuthorizerData.java\nindex c6e3b74a2a..b52a02562f 100644\n--- a/metadata/src/main/java/org/apache/kafka/metadata/authorizer/StandardAuthorizerData.java\n+++ b/metadata/src/main/java/org/apache/kafka/metadata/authorizer/StandardAuthorizerData.java\n@@ -352,8 +352,10 @@ public class StandardAuthorizerData {\n         // This code relies on the ordering of StandardAcl within the NavigableMap.\n         // Entries are sorted by resource type first, then REVERSE resource name.\n         // Therefore, we can find all the applicable ACLs by starting at\n-        // (resource_type, resource_name) and stepping forwards until we reach an ACL with\n-        // a resource name which is not a prefix of the current one.\n+        // (resource_type, resource_name) and stepping forwards until we reach\n+        // an ACL with a resource name which is not a prefix of the current one.\n+        // At that point, we need to search for if there are any more ACLs at\n+        // the first divergence point.\n         //\n         // For example, when trying to authorize a TOPIC resource named foobar, we would\n         // start at element 2, and continue on to 3 and 4 following map:\n@@ -362,9 +364,12 @@ public class StandardAuthorizerData {\n         // 2. rs=TOPIC rn=foobar pt=PREFIX\n         // 3. rs=TOPIC rn=foob pt=LITERAL\n         // 4. rs=TOPIC rn=foo pt=PREFIX\n-        // 5. rs=TOPIC rn=eeee pt=LITERAL\n+        // 5. rs=TOPIC rn=fb pt=PREFIX\n+        // 6. rs=TOPIC rn=fa pt=PREFIX\n+        // 7. rs=TOPIC rn=f  pt=PREFIX\n+        // 8. rs=TOPIC rn=eeee pt=LITERAL\n         //\n-        // Once we reached element 5, we would stop scanning.\n+        // Once we reached element 5, we would jump to element 7.\n         MatchingAclBuilder matchingAclBuilder = new MatchingAclBuilder();\n         StandardAcl exemplar = new StandardAcl(\n             action.resourcePattern().resourceType(),\n@@ -394,6 +399,20 @@ public class StandardAuthorizerData {\n         return matchingAclBuilder.build();\n     }\n \n+    static int matchesUpTo(\n+        String resource,\n+        String pattern\n+    ) {\n+        int i = 0;\n+        while (true) {\n+            if (resource.length() == i) break;\n+            if (pattern.length() == i) break;\n+            if (resource.charAt(i) != pattern.charAt(i)) break;\n+            i++;\n+        }\n+        return i;\n+    }\n+\n     private void checkSection(\n         Action action,\n         StandardAcl exemplar,\n@@ -401,18 +420,19 @@ public class StandardAuthorizerData {\n         String host,\n         MatchingAclBuilder matchingAclBuilder\n     ) {\n-        NavigableSet<StandardAcl> tailSet = aclsByResource.tailSet(exemplar, true);\n         String resourceName = action.resourcePattern().name();\n-        for (Iterator<StandardAcl> iterator = tailSet.iterator();\n-             iterator.hasNext(); ) {\n+        NavigableSet<StandardAcl> tailSet = aclsByResource.tailSet(exemplar, true);\n+        Iterator<StandardAcl> iterator = tailSet.iterator();\n+        while (iterator.hasNext()) {\n             StandardAcl acl = iterator.next();\n             if (!acl.resourceType().equals(action.resourcePattern().resourceType())) {\n                 // We've stepped outside the section for the resource type we care about and\n                 // should stop scanning.\n                 break;\n             }\n-            if (resourceName.startsWith(acl.resourceName())) {\n-                if (acl.patternType() == LITERAL && !resourceName.equals(acl.resourceName())) {\n+            int matchesUpTo = matchesUpTo(resourceName, acl.resourceName());\n+            if (matchesUpTo == acl.resourceName().length()) {\n+                if (acl.patternType() == LITERAL && matchesUpTo != resourceName.length()) {\n                     // This is a literal ACL whose name is a prefix of the resource name, but\n                     // which doesn't match it exactly. We should skip over this ACL, but keep\n                     // scanning in case there are any relevant PREFIX ACLs.\n@@ -421,8 +442,18 @@ public class StandardAuthorizerData {\n             } else if (!(acl.resourceName().equals(WILDCARD) && acl.patternType() == LITERAL)) {\n                 // If the ACL resource name is NOT a prefix of the current resource name,\n                 // and we're not dealing with the special case of a wildcard ACL, we've\n-                // stepped outside of the section we care about and should stop scanning.\n-                break;\n+                // stepped outside of the section we care about. Scan for any other potential\n+                // prefix matches.\n+                exemplar = new StandardAcl(exemplar.resourceType(),\n+                    exemplar.resourceName().substring(0, matchesUpTo),\n+                    exemplar.patternType(),\n+                    exemplar.principal(),\n+                    exemplar.host(),\n+                    exemplar.operation(),\n+                    exemplar.permissionType());\n+                tailSet = aclsByResource.tailSet(exemplar, true);\n+                iterator = tailSet.iterator();\n+                continue;\n             }\n             AuthorizationResult result = findResult(action, matchingPrincipals, host, acl);\n             if (ALLOWED == result) {\n",
  "files": 1,
  "linesAdd": 41,
  "linesRem": 11,
  "failing_tests": [],
  "nb_test": 0,
  "nb_failure": 0,
  "nb_error": 0,
  "nb_skipped": 0
}