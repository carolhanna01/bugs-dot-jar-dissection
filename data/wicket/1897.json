{"nb_failure": 0, "nb_error": 1, "failing_tests": ["testBug(org.apache.wicket.stateless.pages.StatelessFormTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java b/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\nindex 097d44b..892b17a 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\n@@ -1,196 +1,196 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.wicket.request.target.component;\n-\n-import org.apache.wicket.Component;\n-import org.apache.wicket.Page;\n-import org.apache.wicket.PageParameters;\n-import org.apache.wicket.RequestCycle;\n-import org.apache.wicket.RequestListenerInterface;\n-import org.apache.wicket.Session;\n-import org.apache.wicket.WicketRuntimeException;\n-import org.apache.wicket.protocol.http.PageExpiredException;\n-import org.apache.wicket.protocol.http.request.WebRequestCodingStrategy;\n-import org.apache.wicket.util.string.AppendingStringBuffer;\n-import org.apache.wicket.util.string.Strings;\n-\n-/**\n- * Request target for bookmarkable page links that also contain component path and interface name.\n- * This is used for stateless forms and stateless links.\n- * \n- * @author Matej Knopp\n- */\n-public class BookmarkableListenerInterfaceRequestTarget extends BookmarkablePageRequestTarget\n-{\n-\tprivate final String componentPath;\n-\tprivate final String interfaceName;\n-\n-\t/**\n-\t * This constructor is called when a stateless link is clicked on but the page wasn't found in\n-\t * the session. Then this class will recreate the page and call the interface method on the\n-\t * component that is targeted with the component path.\n-\t * \n-\t * @param pageMapName\n-\t * @param pageClass\n-\t * @param pageParameters\n-\t * @param componentPath\n-\t * @param interfaceName\n-\t * @param versionNumber\n-\t */\n-\tpublic BookmarkableListenerInterfaceRequestTarget(String pageMapName,\n-\t\tClass<? extends Page> pageClass, PageParameters pageParameters, String componentPath,\n-\t\tString interfaceName, int versionNumber)\n-\t{\n-\t\tsuper(pageMapName, pageClass, pageParameters);\n-\t\tthis.componentPath = componentPath;\n-\t\tthis.interfaceName = interfaceName;\n-\t}\n-\n-\t/**\n-\t * This constructor is called for generating the urls (RequestCycle.urlFor()) So it will alter\n-\t * the PageParameters to include the 2 org.apache.wicket params\n-\t * {@link WebRequestCodingStrategy#BOOKMARKABLE_PAGE_PARAMETER_NAME} and\n-\t * {@link WebRequestCodingStrategy#INTERFACE_PARAMETER_NAME}\n-\t * \n-\t * @param pageMapName\n-\t * @param pageClass\n-\t * @param pageParameters\n-\t * @param component\n-\t * @param listenerInterface\n-\t */\n-\tpublic BookmarkableListenerInterfaceRequestTarget(String pageMapName,\n-\t\tClass<? extends Page> pageClass, PageParameters pageParameters, Component component,\n-\t\tRequestListenerInterface listenerInterface)\n-\t{\n-\t\tthis(pageMapName, pageClass, pageParameters, component.getPath(),\n-\t\t\tlistenerInterface.getName(), component.getPage().getCurrentVersionNumber());\n-\n-\t\tint version = component.getPage().getCurrentVersionNumber();\n-\t\tsetPage(component.getPage());\n-\n-\t\t// add the wicket:interface param to the params.\n-\t\t// pagemap:(pageid:componenta:componentb:...):version:interface:behavior:urlDepth\n-\t\tAppendingStringBuffer param = new AppendingStringBuffer(4 + componentPath.length() +\n-\t\t\tinterfaceName.length());\n-\t\tif (pageMapName != null)\n-\t\t{\n-\t\t\tparam.append(pageMapName);\n-\t\t}\n-\t\tparam.append(Component.PATH_SEPARATOR);\n-\t\tparam.append(getComponentPath());\n-\t\tparam.append(Component.PATH_SEPARATOR);\n-\t\tif (version != 0)\n-\t\t{\n-\t\t\tparam.append(version);\n-\t\t}\n-\t\t// Interface\n-\t\tparam.append(Component.PATH_SEPARATOR);\n-\t\tparam.append(getInterfaceName());\n-\n-\t\t// Behavior (none)\n-\t\tparam.append(Component.PATH_SEPARATOR);\n-\n-\t\t// URL depth (not required)\n-\t\tparam.append(Component.PATH_SEPARATOR);\n-\n-\t\tpageParameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, param.toString());\n-\t}\n-\n-\t@Override\n-\tpublic void processEvents(RequestCycle requestCycle)\n-\t{\n-\t\tPage page = getPage();\n-\t\tif (page == null)\n-\t\t{\n-\t\t\tpage = Session.get().getPage(getPageMapName(), componentPath, -1);\n-\t\t\tif (page != null)\n-\t\t\t{\n-\t\t\t\tsetPage(page);\n-\t\t\t}\n-\t\t\telse if (page == null)\n-\t\t\t{\n-\t\t\t\tpage = getPage(requestCycle);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (page == null)\n-\t\t{\n-\t\t\tthrow new PageExpiredException(\n-\t\t\t\t\"Request cannot be processed. The target page does not exist anymore.\");\n-\t\t}\n-\n-\t\tfinal String pageRelativeComponentPath = Strings.afterFirstPathComponent(componentPath,\n-\t\t\tComponent.PATH_SEPARATOR);\n-\t\tComponent component = page.get(pageRelativeComponentPath);\n-\t\tif (component == null)\n-\t\t{\n-\t\t\t// this is quite a hack to get components in repeater work.\n-\t\t\t// But it still can fail if the repeater is a paging one or on every render\n-\t\t\t// it will generate new index for the items...\n-\t\t\tpage.prepareForRender(false);\n-\t\t\tcomponent = page.get(pageRelativeComponentPath);\n-\t\t\tif (component == null)\n-\t\t\t{\n-\t\t\t\tthrow new WicketRuntimeException(\n-\t\t\t\t\t\"unable to find component with path \" +\n-\t\t\t\t\t\tpageRelativeComponentPath +\n-\t\t\t\t\t\t\" on stateless page \" +\n-\t\t\t\t\t\tpage +\n-\t\t\t\t\t\t\" it could be that the component is inside a repeater make your component return false in getStatelessHint()\");\n-\t\t\t}\n-\t\t}\n-\t\tRequestListenerInterface listenerInterface = RequestListenerInterface.forName(interfaceName);\n-\t\tif (listenerInterface == null)\n-\t\t{\n-\t\t\tthrow new WicketRuntimeException(\"unable to find listener interface \" + interfaceName);\n-\t\t}\n-\t\tlistenerInterface.invoke(page, component);\n-\t}\n-\n-\t@Override\n-\tpublic void respond(RequestCycle requestCycle)\n-\t{\n-\t\tPage page = getPage(requestCycle);\n-\t\t// if the listener call wanted to redirect\n-\t\t// then do that if the page is not stateless.\n-\t\tif (requestCycle.isRedirect() && !page.isPageStateless())\n-\t\t{\n-\t\t\trequestCycle.redirectTo(page);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// else render the page directly\n-\t\t\tpage.renderPage();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * @return The component path.\n-\t */\n-\tpublic String getComponentPath()\n-\t{\n-\t\treturn componentPath;\n-\t}\n-\n-\t/**\n-\t * @return The interface name\n-\t */\n-\tpublic String getInterfaceName()\n-\t{\n-\t\treturn interfaceName;\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.wicket.request.target.component;\r\n+\r\n+import org.apache.wicket.Component;\r\n+import org.apache.wicket.Page;\r\n+import org.apache.wicket.PageParameters;\r\n+import org.apache.wicket.RequestCycle;\r\n+import org.apache.wicket.RequestListenerInterface;\r\n+import org.apache.wicket.Session;\r\n+import org.apache.wicket.WicketRuntimeException;\r\n+import org.apache.wicket.protocol.http.PageExpiredException;\r\n+import org.apache.wicket.protocol.http.request.WebRequestCodingStrategy;\r\n+import org.apache.wicket.util.string.AppendingStringBuffer;\r\n+import org.apache.wicket.util.string.Strings;\r\n+\r\n+/**\r\n+ * Request target for bookmarkable page links that also contain component path and interface name.\r\n+ * This is used for stateless forms and stateless links.\r\n+ * \r\n+ * @author Matej Knopp\r\n+ */\r\n+public class BookmarkableListenerInterfaceRequestTarget extends BookmarkablePageRequestTarget\r\n+{\r\n+\tprivate final String componentPath;\r\n+\tprivate final String interfaceName;\r\n+\r\n+\t/**\r\n+\t * This constructor is called when a stateless link is clicked on but the page wasn't found in\r\n+\t * the session. Then this class will recreate the page and call the interface method on the\r\n+\t * component that is targeted with the component path.\r\n+\t * \r\n+\t * @param pageMapName\r\n+\t * @param pageClass\r\n+\t * @param pageParameters\r\n+\t * @param componentPath\r\n+\t * @param interfaceName\r\n+\t * @param versionNumber\r\n+\t */\r\n+\tpublic BookmarkableListenerInterfaceRequestTarget(String pageMapName,\r\n+\t\tClass<? extends Page> pageClass, PageParameters pageParameters, String componentPath,\r\n+\t\tString interfaceName, int versionNumber)\r\n+\t{\r\n+\t\tsuper(pageMapName, pageClass, pageParameters);\r\n+\t\tthis.componentPath = componentPath;\r\n+\t\tthis.interfaceName = interfaceName;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * This constructor is called for generating the urls (RequestCycle.urlFor()) So it will alter\r\n+\t * the PageParameters to include the 2 org.apache.wicket params\r\n+\t * {@link WebRequestCodingStrategy#BOOKMARKABLE_PAGE_PARAMETER_NAME} and\r\n+\t * {@link WebRequestCodingStrategy#INTERFACE_PARAMETER_NAME}\r\n+\t * \r\n+\t * @param pageMapName\r\n+\t * @param pageClass\r\n+\t * @param pageParameters\r\n+\t * @param component\r\n+\t * @param listenerInterface\r\n+\t */\r\n+\tpublic BookmarkableListenerInterfaceRequestTarget(String pageMapName,\r\n+\t\tClass<? extends Page> pageClass, PageParameters pageParameters, Component component,\r\n+\t\tRequestListenerInterface listenerInterface)\r\n+\t{\r\n+\t\tthis(pageMapName, pageClass, pageParameters, component.getPath(),\r\n+\t\t\tlistenerInterface.getName(), component.getPage().getCurrentVersionNumber());\r\n+\r\n+\t\tint version = component.getPage().getCurrentVersionNumber();\r\n+\t\tsetPage(component.getPage());\r\n+\r\n+\t\t// add the wicket:interface param to the params.\r\n+\t\t// pagemap:(pageid:componenta:componentb:...):version:interface:behavior:urlDepth\r\n+\t\tAppendingStringBuffer param = new AppendingStringBuffer(4 + componentPath.length() +\r\n+\t\t\tinterfaceName.length());\r\n+\t\tif (pageMapName != null)\r\n+\t\t{\r\n+\t\t\tparam.append(pageMapName);\r\n+\t\t}\r\n+\t\tparam.append(Component.PATH_SEPARATOR);\r\n+\t\tparam.append(getComponentPath());\r\n+\t\tparam.append(Component.PATH_SEPARATOR);\r\n+\t\tif (version != 0)\r\n+\t\t{\r\n+\t\t\tparam.append(version);\r\n+\t\t}\r\n+\t\t// Interface\r\n+\t\tparam.append(Component.PATH_SEPARATOR);\r\n+\t\tparam.append(getInterfaceName());\r\n+\r\n+\t\t// Behavior (none)\r\n+\t\tparam.append(Component.PATH_SEPARATOR);\r\n+\r\n+\t\t// URL depth (not required)\r\n+\t\tparam.append(Component.PATH_SEPARATOR);\r\n+\r\n+\t\tpageParameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, param.toString());\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void processEvents(RequestCycle requestCycle)\r\n+\t{\r\n+\t\tPage page = getPage();\r\n+\t\tif (page == null)\r\n+\t\t{\r\n+\t\t\tpage = Session.get().getPage(getPageMapName(), componentPath, -1);\r\n+\t\t\tif (page != null && page.getClass() == getPageClass())\r\n+\t\t\t{\r\n+\t\t\t\tsetPage(page);\r\n+\t\t\t}\r\n+\t\t\telse\r\n+\t\t\t{\r\n+\t\t\t\tpage = getPage(requestCycle);\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\tif (page == null)\r\n+\t\t{\r\n+\t\t\tthrow new PageExpiredException(\r\n+\t\t\t\t\"Request cannot be processed. The target page does not exist anymore.\");\r\n+\t\t}\r\n+\r\n+\t\tfinal String pageRelativeComponentPath = Strings.afterFirstPathComponent(componentPath,\r\n+\t\t\tComponent.PATH_SEPARATOR);\r\n+\t\tComponent component = page.get(pageRelativeComponentPath);\r\n+\t\tif (component == null)\r\n+\t\t{\r\n+\t\t\t// this is quite a hack to get components in repeater work.\r\n+\t\t\t// But it still can fail if the repeater is a paging one or on every render\r\n+\t\t\t// it will generate new index for the items...\r\n+\t\t\tpage.prepareForRender(false);\r\n+\t\t\tcomponent = page.get(pageRelativeComponentPath);\r\n+\t\t\tif (component == null)\r\n+\t\t\t{\r\n+\t\t\t\tthrow new WicketRuntimeException(\r\n+\t\t\t\t\t\"unable to find component with path \" +\r\n+\t\t\t\t\t\tpageRelativeComponentPath +\r\n+\t\t\t\t\t\t\" on stateless page \" +\r\n+\t\t\t\t\t\tpage +\r\n+\t\t\t\t\t\t\" it could be that the component is inside a repeater make your component return false in getStatelessHint()\");\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\tRequestListenerInterface listenerInterface = RequestListenerInterface.forName(interfaceName);\r\n+\t\tif (listenerInterface == null)\r\n+\t\t{\r\n+\t\t\tthrow new WicketRuntimeException(\"unable to find listener interface \" + interfaceName);\r\n+\t\t}\r\n+\t\tlistenerInterface.invoke(page, component);\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void respond(RequestCycle requestCycle)\r\n+\t{\r\n+\t\tPage page = getPage(requestCycle);\r\n+\t\t// if the listener call wanted to redirect\r\n+\t\t// then do that if the page is not stateless.\r\n+\t\tif (requestCycle.isRedirect() && !page.isPageStateless())\r\n+\t\t{\r\n+\t\t\trequestCycle.redirectTo(page);\r\n+\t\t}\r\n+\t\telse\r\n+\t\t{\r\n+\t\t\t// else render the page directly\r\n+\t\t\tpage.renderPage();\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * @return The component path.\r\n+\t */\r\n+\tpublic String getComponentPath()\r\n+\t{\r\n+\t\treturn componentPath;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * @return The interface name\r\n+\t */\r\n+\tpublic String getInterfaceName()\r\n+\t{\r\n+\t\treturn interfaceName;\r\n+\t}\r\n+}\r\n", "nb_test": 794, "nb_skipped": 0, "fix_commit": "8ee095bf", "id": "1897"}