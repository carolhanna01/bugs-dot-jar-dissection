{
  "files": 4, 
  "singleLine": false, 
  "nb_error": 0, 
  "failing_tests": [
    "ignoreBOM(org.apache.wicket.util.io.XmlReaderTest): expected:<UTF-8> but was:<null>"
  ], 
  "nb_test": 171, 
  "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/io/BOMInputStream.java b/wicket-util/src/main/java/org/apache/wicket/util/io/BOMInputStream.java\nnew file mode 100644\nindex 0000000..b870278\n--- /dev/null\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/io/BOMInputStream.java\n@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.io;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * This class is used to wrap a stream that includes an encoded {@link ByteOrderMark} as its first bytes.\n+ * \n+ * This class detects these bytes and, if required, can automatically skip them and return the subsequent byte as the\n+ * first byte in the stream.\n+ * \n+ * The {@link ByteOrderMark} implementation has the following pre-defined BOMs:\n+ * <ul>\n+ * <li>UTF-8 - {@link ByteOrderMark#UTF_8}</li>\n+ * <li>UTF-16BE - {@link ByteOrderMark#UTF_16LE}</li>\n+ * <li>UTF-16LE - {@link ByteOrderMark#UTF_16BE}</li>\n+ * <li>UTF-32BE - {@link ByteOrderMark#UTF_32LE}</li>\n+ * <li>UTF-32LE - {@link ByteOrderMark#UTF_32BE}</li>\n+ * </ul>\n+ * \n+ * \n+ * <h3>Example 1 - Detect and exclude a UTF-8 BOM</h3>\n+ * \n+ * <pre>\n+ * BOMInputStream bomIn = new BOMInputStream(in);\n+ * if (bomIn.hasBOM()) {\n+ *     // has a UTF-8 BOM\n+ * }\n+ * </pre>\n+ * \n+ * <h3>Example 2 - Detect a UTF-8 BOM (but don't exclude it)</h3>\n+ * \n+ * <pre>\n+ * boolean include = true;\n+ * BOMInputStream bomIn = new BOMInputStream(in, include);\n+ * if (bomIn.hasBOM()) {\n+ *     // has a UTF-8 BOM\n+ * }\n+ * </pre>\n+ * \n+ * <h3>Example 3 - Detect Multiple BOMs</h3>\n+ * \n+ * <pre>\n+ * BOMInputStream bomIn = new BOMInputStream(in, \n+ *   ByteOrderMark.UTF_16LE, ByteOrderMark.UTF_16BE,\n+ *   ByteOrderMark.UTF_32LE, ByteOrderMark.UTF_32BE\n+ *   );\n+ * if (bomIn.hasBOM() == false) {\n+ *     // No BOM found\n+ * } else if (bomIn.hasBOM(ByteOrderMark.UTF_16LE)) {\n+ *     // has a UTF-16LE BOM\n+ * } else if (bomIn.hasBOM(ByteOrderMark.UTF_16BE)) {\n+ *     // has a UTF-16BE BOM\n+ * } else if (bomIn.hasBOM(ByteOrderMark.UTF_32LE)) {\n+ *     // has a UTF-32LE BOM\n+ * } else if (bomIn.hasBOM(ByteOrderMark.UTF_32BE)) {\n+ *     // has a UTF-32BE BOM\n+ * }\n+ * </pre>\n+ * \n+ * @see ByteOrderMark\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Byte_order_mark\">Wikipedia - Byte Order Mark</a>\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public class BOMInputStream extends ProxyInputStream\n+{\n+    private final boolean include;\n+    /**\n+     * BOMs are sorted from longest to shortest.\n+     */\n+    private final List<ByteOrderMark> boms;\n+    private ByteOrderMark byteOrderMark;\n+    private int[] firstBytes;\n+    private int fbLength;\n+    private int fbIndex;\n+    private int markFbIndex;\n+    private boolean markedAtStart;\n+\n+    /**\n+     * Constructs a new BOM InputStream that excludes a {@link ByteOrderMark#UTF_8} BOM.\n+     * \n+     * @param delegate\n+     *            the InputStream to delegate to\n+     */\n+    public BOMInputStream(final InputStream delegate) {\n+        this(delegate, false, ByteOrderMark.UTF_8);\n+    }\n+\n+    /**\n+     * Constructs a new BOM InputStream that detects a a {@link ByteOrderMark#UTF_8} and optionally includes it.\n+     * \n+     * @param delegate\n+     *            the InputStream to delegate to\n+     * @param include\n+     *            true to include the UTF-8 BOM or false to exclude it\n+     */\n+    public BOMInputStream(final InputStream delegate, final boolean include) {\n+        this(delegate, include, ByteOrderMark.UTF_8);\n+    }\n+\n+    /**\n+     * Constructs a new BOM InputStream that excludes the specified BOMs.\n+     * \n+     * @param delegate\n+     *            the InputStream to delegate to\n+     * @param boms\n+     *            The BOMs to detect and exclude\n+     */\n+    public BOMInputStream(final InputStream delegate, final ByteOrderMark... boms) {\n+        this(delegate, false, boms);\n+    }\n+\n+    /**\n+     * Compares ByteOrderMark objects in descending length order.\n+     */\n+    private static final Comparator<ByteOrderMark> ByteOrderMarkLengthComparator = new Comparator<ByteOrderMark>() {\n+\n+        public int compare(final ByteOrderMark bom1, final ByteOrderMark bom2) {\n+            final int len1 = bom1.length();\n+            final int len2 = bom2.length();\n+            if (len1 > len2) {\n+                return -1;\n+            }\n+            if (len2 > len1) {\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    };\n+\n+    /**\n+     * Constructs a new BOM InputStream that detects the specified BOMs and optionally includes them.\n+     * \n+     * @param delegate\n+     *            the InputStream to delegate to\n+     * @param include\n+     *            true to include the specified BOMs or false to exclude them\n+     * @param boms\n+     *            The BOMs to detect and optionally exclude\n+     */\n+    public BOMInputStream(final InputStream delegate, final boolean include, final ByteOrderMark... boms) {\n+        super(delegate);\n+        if (boms == null || boms.length == 0) {\n+            throw new IllegalArgumentException(\"No BOMs specified\");\n+        }\n+        this.include = include;\n+        // Sort the BOMs to match the longest BOM first because some BOMs have the same starting two bytes.\n+        Arrays.sort(boms, ByteOrderMarkLengthComparator);\n+        this.boms = Arrays.asList(boms);\n+\n+    }\n+\n+    /**\n+     * Indicates whether the stream contains one of the specified BOMs.\n+     * \n+     * @return true if the stream has one of the specified BOMs, otherwise false if it does not\n+     * @throws IOException\n+     *             if an error reading the first bytes of the stream occurs\n+     */\n+    public boolean hasBOM() throws IOException {\n+        return getBOM() != null;\n+    }\n+\n+    /**\n+     * Indicates whether the stream contains the specified BOM.\n+     * \n+     * @param bom\n+     *            The BOM to check for\n+     * @return true if the stream has the specified BOM, otherwise false if it does not\n+     * @throws IllegalArgumentException\n+     *             if the BOM is not one the stream is configured to detect\n+     * @throws IOException\n+     *             if an error reading the first bytes of the stream occurs\n+     */\n+    public boolean hasBOM(final ByteOrderMark bom) throws IOException {\n+        if (!boms.contains(bom)) {\n+            throw new IllegalArgumentException(\"Stream not configure to detect \" + bom);\n+        }\n+        return byteOrderMark != null && getBOM().equals(bom);\n+    }\n+\n+    /**\n+     * Return the BOM (Byte Order Mark).\n+     * \n+     * @return The BOM or null if none\n+     * @throws IOException\n+     *             if an error reading the first bytes of the stream occurs\n+     */\n+    public ByteOrderMark getBOM() throws IOException {\n+        if (firstBytes == null) {\n+            fbLength = 0;\n+            // BOMs are sorted from longest to shortest\n+            final int maxBomSize = boms.get(0).length();\n+            firstBytes = new int[maxBomSize];\n+            // Read first maxBomSize bytes\n+            for (int i = 0; i < firstBytes.length; i++) {\n+                firstBytes[i] = in.read();\n+                fbLength++;\n+                if (firstBytes[i] < 0) {\n+                    break;\n+                }\n+            }\n+            // match BOM in firstBytes\n+            byteOrderMark = find();\n+            if (byteOrderMark != null) {\n+                if (!include) {\n+                    if (byteOrderMark.length() < firstBytes.length) {\n+                        fbIndex = byteOrderMark.length();\n+                    } else {\n+                        fbLength = 0;\n+                    }\n+                }\n+            }\n+        }\n+        return byteOrderMark;\n+    }\n+\n+    /**\n+     * Return the BOM charset Name - {@link ByteOrderMark#getCharsetName()}.\n+     * \n+     * @return The BOM charset Name or null if no BOM found\n+     * @throws IOException\n+     *             if an error reading the first bytes of the stream occurs\n+     * \n+     */\n+    public String getBOMCharsetName() throws IOException {\n+        getBOM();\n+        return byteOrderMark == null ? null : byteOrderMark.getCharsetName();\n+    }\n+\n+    /**\n+     * This method reads and either preserves or skips the first bytes in the stream. It behaves like the single-byte\n+     * <code>read()</code> method, either returning a valid byte or -1 to indicate that the initial bytes have been\n+     * processed already.\n+     * \n+     * @return the byte read (excluding BOM) or -1 if the end of stream\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    private int readFirstBytes() throws IOException {\n+        getBOM();\n+        return fbIndex < fbLength ? firstBytes[fbIndex++] : -1;\n+    }\n+\n+    /**\n+     * Find a BOM with the specified bytes.\n+     * \n+     * @return The matched BOM or null if none matched\n+     */\n+    private ByteOrderMark find() {\n+        for (final ByteOrderMark bom : boms) {\n+            if (matches(bom)) {\n+                return bom;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Check if the bytes match a BOM.\n+     * \n+     * @param bom\n+     *            The BOM\n+     * @return true if the bytes match the bom, otherwise false\n+     */\n+    private boolean matches(final ByteOrderMark bom) {\n+        // if (bom.length() != fbLength) {\n+        // return false;\n+        // }\n+        // firstBytes may be bigger than the BOM bytes\n+        for (int i = 0; i < bom.length(); i++) {\n+            if (bom.get(i) != firstBytes[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // ----------------------------------------------------------------------------\n+    // Implementation of InputStream\n+    // ----------------------------------------------------------------------------\n+\n+    /**\n+     * Invokes the delegate's <code>read()</code> method, detecting and optionally skipping BOM.\n+     * \n+     * @return the byte read (excluding BOM) or -1 if the end of stream\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Override\n+    public int read() throws IOException {\n+        final int b = readFirstBytes();\n+        return b >= 0 ? b : in.read();\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>read(byte[], int, int)</code> method, detecting and optionally skipping BOM.\n+     * \n+     * @param buf\n+     *            the buffer to read the bytes into\n+     * @param off\n+     *            The start offset\n+     * @param len\n+     *            The number of bytes to read (excluding BOM)\n+     * @return the number of bytes read or -1 if the end of stream\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Override\n+    public int read(final byte[] buf, int off, int len) throws IOException {\n+        int firstCount = 0;\n+        int b = 0;\n+        while (len > 0 && b >= 0) {\n+            b = readFirstBytes();\n+            if (b >= 0) {\n+                buf[off++] = (byte) (b & 0xFF);\n+                len--;\n+                firstCount++;\n+            }\n+        }\n+        final int secondCount = in.read(buf, off, len);\n+        return secondCount < 0 ? firstCount > 0 ? firstCount : -1 : firstCount + secondCount;\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>read(byte[])</code> method, detecting and optionally skipping BOM.\n+     * \n+     * @param buf\n+     *            the buffer to read the bytes into\n+     * @return the number of bytes read (excluding BOM) or -1 if the end of stream\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Override\n+    public int read(final byte[] buf) throws IOException {\n+        return read(buf, 0, buf.length);\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>mark(int)</code> method.\n+     * \n+     * @param readlimit\n+     *            read ahead limit\n+     */\n+    @Override\n+    public synchronized void mark(final int readlimit) {\n+        markFbIndex = fbIndex;\n+        markedAtStart = firstBytes == null;\n+        in.mark(readlimit);\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>reset()</code> method.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Override\n+    public synchronized void reset() throws IOException {\n+        fbIndex = markFbIndex;\n+        if (markedAtStart) {\n+            firstBytes = null;\n+        }\n+\n+        in.reset();\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>skip(long)</code> method, detecting and optionallyskipping BOM.\n+     * \n+     * @param n\n+     *            the number of bytes to skip\n+     * @return the number of bytes to skipped or -1 if the end of stream\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Override\n+    public long skip(long n) throws IOException {\n+        while (n > 0 && readFirstBytes() >= 0) {\n+            n--;\n+        }\n+        return in.skip(n);\n+    }\n+}\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/io/ByteOrderMark.java b/wicket-util/src/main/java/org/apache/wicket/util/io/ByteOrderMark.java\nnew file mode 100644\nindex 0000000..e1ee046\n--- /dev/null\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/io/ByteOrderMark.java\n@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.io;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Byte Order Mark (BOM) representation - see {@link BOMInputStream}.\n+ *\n+ * @see BOMInputStream\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Byte_order_mark\">Wikipedia: Byte Order Mark</a>\n+ * @see <a href=\"http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing\">W3C: Autodetection of Character Encodings\n+ *      (Non-Normative)</a>\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public class ByteOrderMark implements Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /** UTF-8 BOM */\n+    public static final ByteOrderMark UTF_8    = new ByteOrderMark(\"UTF-8\",    0xEF, 0xBB, 0xBF);\n+\n+    /** UTF-16BE BOM (Big-Endian) */\n+    public static final ByteOrderMark UTF_16BE = new ByteOrderMark(\"UTF-16BE\", 0xFE, 0xFF);\n+\n+    /** UTF-16LE BOM (Little-Endian) */\n+    public static final ByteOrderMark UTF_16LE = new ByteOrderMark(\"UTF-16LE\", 0xFF, 0xFE);\n+\n+    /**\n+     * UTF-32BE BOM (Big-Endian)\n+     * @since 2.2\n+     */\n+    public static final ByteOrderMark UTF_32BE = new ByteOrderMark(\"UTF-32BE\", 0x00, 0x00, 0xFE, 0xFF);\n+\n+    /**\n+     * UTF-32LE BOM (Little-Endian)\n+     * @since 2.2\n+     */\n+    public static final ByteOrderMark UTF_32LE = new ByteOrderMark(\"UTF-32LE\", 0xFF, 0xFE, 0x00, 0x00);\n+\n+    /**\n+     * Unicode BOM character; external form depends on the encoding.\n+     * @see <a href=\"http://unicode.org/faq/utf_bom.html#BOM\">Byte Order Mark (BOM) FAQ</a>\n+     * @since 2.5\n+     */\n+    public static final char UTF_BOM = '\\uFEFF';\n+\n+    private final String charsetName;\n+    private final int[] bytes;\n+\n+    /**\n+     * Construct a new BOM.\n+     *\n+     * @param charsetName The name of the charset the BOM represents\n+     * @param bytes The BOM's bytes\n+     * @throws IllegalArgumentException if the charsetName is null or\n+     * zero length\n+     * @throws IllegalArgumentException if the bytes are null or zero\n+     * length\n+     */\n+    public ByteOrderMark(final String charsetName, final int... bytes) {\n+        if (charsetName == null || charsetName.length() == 0) {\n+            throw new IllegalArgumentException(\"No charsetName specified\");\n+        }\n+        if (bytes == null || bytes.length == 0) {\n+            throw new IllegalArgumentException(\"No bytes specified\");\n+        }\n+        this.charsetName = charsetName;\n+        this.bytes = new int[bytes.length];\n+        System.arraycopy(bytes, 0, this.bytes, 0, bytes.length);\n+    }\n+\n+    /**\n+     * Return the name of the {@link java.nio.charset.Charset} the BOM represents.\n+     *\n+     * @return the character set name\n+     */\n+    public String getCharsetName() {\n+        return charsetName;\n+    }\n+\n+    /**\n+     * Return the length of the BOM's bytes.\n+     *\n+     * @return the length of the BOM's bytes\n+     */\n+    public int length() {\n+        return bytes.length;\n+    }\n+\n+    /**\n+     * The byte at the specified position.\n+     *\n+     * @param pos The position\n+     * @return The specified byte\n+     */\n+    public int get(final int pos) {\n+        return bytes[pos];\n+    }\n+\n+    /**\n+     * Return a copy of the BOM's bytes.\n+     *\n+     * @return a copy of the BOM's bytes\n+     */\n+    public byte[] getBytes() {\n+        final byte[] copy = new byte[bytes.length];\n+        for (int i = 0; i < bytes.length; i++) {\n+            copy[i] = (byte)bytes[i];\n+        }\n+        return copy;\n+    }\n+\n+    /**\n+     * Indicates if this BOM's bytes equals another.\n+     *\n+     * @param obj The object to compare to\n+     * @return true if the bom's bytes are equal, otherwise\n+     * false\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (!(obj instanceof ByteOrderMark)) {\n+            return false;\n+        }\n+        final ByteOrderMark bom = (ByteOrderMark)obj;\n+        if (bytes.length != bom.length()) {\n+            return false;\n+        }\n+        for (int i = 0; i < bytes.length; i++) {\n+            if (bytes[i] != bom.get(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Return the hashcode for this BOM.\n+     *\n+     * @return the hashcode for this BOM.\n+     * @see java.lang.Object#hashCode()\n+     */\n+    @Override\n+    public int hashCode() {\n+        int hashCode = getClass().hashCode();\n+        for (final int b : bytes) {\n+            hashCode += b;\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * Provide a String representation of the BOM.\n+     *\n+     * @return the length of the BOM's bytes\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder builder = new StringBuilder();\n+        builder.append(getClass().getSimpleName());\n+        builder.append('[');\n+        builder.append(charsetName);\n+        builder.append(\": \");\n+        for (int i = 0; i < bytes.length; i++) {\n+            if (i > 0) {\n+                builder.append(\",\");\n+            }\n+            builder.append(\"0x\");\n+            builder.append(Integer.toHexString(0xFF & bytes[i]).toUpperCase());\n+        }\n+        builder.append(']');\n+        return builder.toString();\n+    }\n+\n+}\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/io/ProxyInputStream.java b/wicket-util/src/main/java/org/apache/wicket/util/io/ProxyInputStream.java\nnew file mode 100644\nindex 0000000..e3d424c\n--- /dev/null\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/io/ProxyInputStream.java\n@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.io;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * A Proxy stream which acts as expected, that is it passes the method\n+ * calls on to the proxied stream and doesn't change which methods are\n+ * being called.\n+ * <p>\n+ * It is an alternative base class to FilterInputStream\n+ * to increase reusability, because FilterInputStream changes the\n+ * methods being called, such as read(byte[]) to read(byte[], int, int).\n+ * <p>\n+ * See the protected methods for ways in which a subclass can easily decorate\n+ * a stream with custom pre-, post- or error processing functionality.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class ProxyInputStream extends FilterInputStream {\n+\n+    /**\n+     * Constructs a new ProxyInputStream.\n+     *\n+     * @param proxy  the InputStream to delegate to\n+     */\n+    public ProxyInputStream(final InputStream proxy) {\n+        super(proxy);\n+        // the proxy is stored in a protected superclass variable named 'in'\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>read()</code> method.\n+     * @return the byte read or -1 if the end of stream\n+     * @throws IOException if an I/O error occurs\n+     */\n+    @Override\n+    public int read() throws IOException {\n+        try {\n+            beforeRead(1);\n+            final int b = in.read();\n+            afterRead(b != -1 ? 1 : -1);\n+            return b;\n+        } catch (final IOException e) {\n+            handleIOException(e);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>read(byte[])</code> method.\n+     * @param bts the buffer to read the bytes into\n+     * @return the number of bytes read or -1 if the end of stream\n+     * @throws IOException if an I/O error occurs\n+     */\n+    @Override\n+    public int read(final byte[] bts) throws IOException {\n+        try {\n+            beforeRead(bts != null ? bts.length : 0);\n+            final int n = in.read(bts);\n+            afterRead(n);\n+            return n;\n+        } catch (final IOException e) {\n+            handleIOException(e);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>read(byte[], int, int)</code> method.\n+     * @param bts the buffer to read the bytes into\n+     * @param off The start offset\n+     * @param len The number of bytes to read\n+     * @return the number of bytes read or -1 if the end of stream\n+     * @throws IOException if an I/O error occurs\n+     */\n+    @Override\n+    public int read(final byte[] bts, final int off, final int len) throws IOException {\n+        try {\n+            beforeRead(len);\n+            final int n = in.read(bts, off, len);\n+            afterRead(n);\n+            return n;\n+        } catch (final IOException e) {\n+            handleIOException(e);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>skip(long)</code> method.\n+     * @param ln the number of bytes to skip\n+     * @return the actual number of bytes skipped\n+     * @throws IOException if an I/O error occurs\n+     */\n+    @Override\n+    public long skip(final long ln) throws IOException {\n+        try {\n+            return in.skip(ln);\n+        } catch (final IOException e) {\n+            handleIOException(e);\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>available()</code> method.\n+     * @return the number of available bytes\n+     * @throws IOException if an I/O error occurs\n+     */\n+    @Override\n+    public int available() throws IOException {\n+        try {\n+            return super.available();\n+        } catch (final IOException e) {\n+            handleIOException(e);\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>close()</code> method.\n+     * @throws IOException if an I/O error occurs\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        try {\n+            in.close();\n+        } catch (final IOException e) {\n+            handleIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>mark(int)</code> method.\n+     * @param readlimit read ahead limit\n+     */\n+    @Override\n+    public synchronized void mark(final int readlimit) {\n+        in.mark(readlimit);\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>reset()</code> method.\n+     * @throws IOException if an I/O error occurs\n+     */\n+    @Override\n+    public synchronized void reset() throws IOException {\n+        try {\n+            in.reset();\n+        } catch (final IOException e) {\n+            handleIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Invokes the delegate's <code>markSupported()</code> method.\n+     * @return true if mark is supported, otherwise false\n+     */\n+    @Override\n+    public boolean markSupported() {\n+        return in.markSupported();\n+    }\n+\n+    /**\n+     * Invoked by the read methods before the call is proxied. The number\n+     * of bytes that the caller wanted to read (1 for the {@link #read()}\n+     * method, buffer length for {@link #read(byte[])}, etc.) is given as\n+     * an argument.\n+     * <p>\n+     * Subclasses can override this method to add common pre-processing\n+     * functionality without having to override all the read methods.\n+     * The default implementation does nothing.\n+     * <p>\n+     * Note this method is <em>not</em> called from {@link #skip(long)} or\n+     * {@link #reset()}. You need to explicitly override those methods if\n+     * you want to add pre-processing steps also to them.\n+     *\n+     * @since 2.0\n+     * @param n number of bytes that the caller asked to be read\n+     * @throws IOException if the pre-processing fails\n+     */\n+    protected void beforeRead(final int n) throws IOException {\n+    }\n+\n+    /**\n+     * Invoked by the read methods after the proxied call has returned\n+     * successfully. The number of bytes returned to the caller (or -1 if\n+     * the end of stream was reached) is given as an argument.\n+     * <p>\n+     * Subclasses can override this method to add common post-processing\n+     * functionality without having to override all the read methods.\n+     * The default implementation does nothing.\n+     * <p>\n+     * Note this method is <em>not</em> called from {@link #skip(long)} or\n+     * {@link #reset()}. You need to explicitly override those methods if\n+     * you want to add post-processing steps also to them.\n+     *\n+     * @since 2.0\n+     * @param n number of bytes read, or -1 if the end of stream was reached\n+     * @throws IOException if the post-processing fails\n+     */\n+    protected void afterRead(final int n) throws IOException {\n+    }\n+\n+    /**\n+     * Handle any IOExceptions thrown.\n+     * <p>\n+     * This method provides a point to implement custom exception\n+     * handling. The default behaviour is to re-throw the exception.\n+     * @param e The IOException thrown\n+     * @throws IOException if an I/O error occurs\n+     * @since 2.0\n+     */\n+    protected void handleIOException(final IOException e) throws IOException {\n+        throw e;\n+    }\n+\n+}\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/io/XmlReader.java b/wicket-util/src/main/java/org/apache/wicket/util/io/XmlReader.java\nindex ce4c041..1f3a408 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/io/XmlReader.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/io/XmlReader.java\n@@ -70,11 +70,11 @@ public final class XmlReader extends Reader\n \n \t\tif (!inputStream.markSupported())\n \t\t{\n-\t\t\tthis.inputStream = new BufferedInputStream(inputStream);\n+\t\t\tthis.inputStream = new BufferedInputStream(new BOMInputStream(inputStream));\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tthis.inputStream = inputStream;\n+\t\t\tthis.inputStream = new BOMInputStream(inputStream);\n \t\t}\n \t\tencoding = defaultEncoding;\n \n", 
  "project": "wicket", 
  "linesAdd": 833, 
  "nb_skipped": 0, 
  "fix_commit": "87fa630f", 
  "nb_failure": 1, 
  "id": "5416", 
  "linesRem": 2
}