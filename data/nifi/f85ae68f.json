{
  "project": "nifi",
  "jira_id": "9507",
  "commit": "f85ae68f",
  "classification": {
    "singleLine": false
  },
  "patch": "diff --git a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/ListSFTP.java b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/ListSFTP.java\nindex c2c0aeb5f6..19e3215419 100644\n--- a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/ListSFTP.java\n+++ b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/ListSFTP.java\n@@ -79,13 +79,11 @@ public class ListSFTP extends ListFileTransfer {\n \n     @Override\n     protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {\n-        final PropertyDescriptor port = new PropertyDescriptor.Builder().fromPropertyDescriptor(UNDEFAULTED_PORT).defaultValue(\"22\").build();\n-\n         final List<PropertyDescriptor> properties = new ArrayList<>();\n         properties.add(FILE_TRANSFER_LISTING_STRATEGY);\n-        properties.add(HOSTNAME);\n-        properties.add(port);\n-        properties.add(USERNAME);\n+        properties.add(SFTPTransfer.HOSTNAME);\n+        properties.add(SFTPTransfer.PORT);\n+        properties.add(SFTPTransfer.USERNAME);\n         properties.add(SFTPTransfer.PASSWORD);\n         properties.add(SFTPTransfer.PRIVATE_KEY_PATH);\n         properties.add(SFTPTransfer.PRIVATE_KEY_PASSPHRASE);\n@@ -103,6 +101,7 @@ public class ListSFTP extends ListFileTransfer {\n         properties.add(SFTPTransfer.DATA_TIMEOUT);\n         properties.add(SFTPTransfer.USE_KEEPALIVE_ON_TIMEOUT);\n         properties.add(TARGET_SYSTEM_TIMESTAMP_PRECISION);\n+        properties.add(SFTPTransfer.USE_COMPRESSION);\n         properties.add(SFTPTransfer.PROXY_CONFIGURATION_SERVICE);\n         properties.add(FTPTransfer.PROXY_TYPE);\n         properties.add(FTPTransfer.PROXY_HOST);\ndiff --git a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/util/SFTPTransfer.java b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/util/SFTPTransfer.java\nindex 1082dd7ef3..1636bbd847 100644\n--- a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/util/SFTPTransfer.java\n+++ b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/util/SFTPTransfer.java\n@@ -16,13 +16,9 @@\n  */\n package org.apache.nifi.processors.standard.util;\n \n-import net.schmizz.keepalive.KeepAlive;\n-import net.schmizz.keepalive.KeepAliveProvider;\n-import net.schmizz.sshj.Config;\n import net.schmizz.sshj.DefaultConfig;\n import net.schmizz.sshj.SSHClient;\n import net.schmizz.sshj.common.Factory;\n-import net.schmizz.sshj.connection.ConnectionImpl;\n import net.schmizz.sshj.sftp.FileAttributes;\n import net.schmizz.sshj.sftp.FileMode;\n import net.schmizz.sshj.sftp.RemoteFile;\n@@ -31,17 +27,6 @@ import net.schmizz.sshj.sftp.RemoteResourceInfo;\n import net.schmizz.sshj.sftp.Response;\n import net.schmizz.sshj.sftp.SFTPClient;\n import net.schmizz.sshj.sftp.SFTPException;\n-import net.schmizz.sshj.transport.verification.PromiscuousVerifier;\n-import net.schmizz.sshj.userauth.keyprovider.KeyFormat;\n-import net.schmizz.sshj.userauth.keyprovider.KeyProvider;\n-import net.schmizz.sshj.userauth.keyprovider.KeyProviderUtil;\n-import net.schmizz.sshj.userauth.method.AuthKeyboardInteractive;\n-import net.schmizz.sshj.userauth.method.AuthMethod;\n-import net.schmizz.sshj.userauth.method.AuthPassword;\n-import net.schmizz.sshj.userauth.method.AuthPublickey;\n-import net.schmizz.sshj.userauth.method.PasswordResponseProvider;\n-import net.schmizz.sshj.userauth.password.PasswordFinder;\n-import net.schmizz.sshj.userauth.password.PasswordUtils;\n import net.schmizz.sshj.xfer.FilePermission;\n import net.schmizz.sshj.xfer.LocalSourceFile;\n import org.apache.nifi.components.PropertyDescriptor;\n@@ -58,39 +43,35 @@ import org.apache.nifi.processor.ProcessSession;\n import org.apache.nifi.processor.exception.ProcessException;\n import org.apache.nifi.processor.io.OutputStreamCallback;\n import org.apache.nifi.processor.util.StandardValidators;\n+import org.apache.nifi.processors.standard.ssh.SSHClientProvider;\n+import org.apache.nifi.processors.standard.ssh.StandardSSHClientProvider;\n import org.apache.nifi.proxy.ProxyConfiguration;\n import org.apache.nifi.proxy.ProxySpec;\n import org.apache.nifi.stream.io.StreamUtils;\n \n-import javax.net.SocketFactory;\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.net.InetAddress;\n-import java.net.Proxy;\n-import java.net.Socket;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n-import static org.apache.nifi.processors.standard.util.FTPTransfer.createComponentProxyConfigSupplier;\n-\n public class SFTPTransfer implements FileTransfer {\n-    private static final int KEEP_ALIVE_INTERVAL_SECONDS = 5;\n+    private static final SSHClientProvider SSH_CLIENT_PROVIDER = new StandardSSHClientProvider();\n \n     private static final Set<String> DEFAULT_KEY_ALGORITHM_NAMES;\n     private static final Set<String> DEFAULT_CIPHER_NAMES;\n@@ -561,32 +542,6 @@ public class SFTPTransfer implements FileTransfer {\n         }\n     }\n \n-    private static final KeepAliveProvider NO_OP_KEEP_ALIVE = new KeepAliveProvider() {\n-        @Override\n-        public KeepAlive provide(final ConnectionImpl connection) {\n-            return new KeepAlive(connection, \"no-op-keep-alive\") {\n-                @Override\n-                protected void doKeepAlive() {\n-                    // do nothing;\n-                }\n-            };\n-        }\n-    };\n-\n-    private static final KeepAliveProvider DEFAULT_KEEP_ALIVE_PROVIDER = new KeepAliveProvider() {\n-        @Override\n-        public KeepAlive provide(final ConnectionImpl connection) {\n-            final KeepAlive keepAlive = KeepAliveProvider.KEEP_ALIVE.provide(connection);\n-            keepAlive.setKeepAliveInterval(KEEP_ALIVE_INTERVAL_SECONDS);\n-            return keepAlive;\n-        }\n-    };\n-\n-    protected KeepAliveProvider getKeepAliveProvider() {\n-        final boolean useKeepAliveOnTimeout = ctx.getProperty(USE_KEEPALIVE_ON_TIMEOUT).asBoolean();\n-        return useKeepAliveOnTimeout ? DEFAULT_KEEP_ALIVE_PROVIDER : NO_OP_KEEP_ALIVE;\n-    }\n-\n     protected SFTPClient getSFTPClient(final FlowFile flowFile) throws IOException {\n         // If the client is already initialized then compare the host that the client is connected to with the current\n         // host from the properties/flow-file, and if different then we need to close and reinitialize, if same we can reuse\n@@ -602,95 +557,8 @@ public class SFTPTransfer implements FileTransfer {\n             }\n         }\n \n-        // Initialize a new SSHClient...\n-        final DefaultConfig sshClientConfig = new DefaultConfig();\n-        sshClientConfig.setKeepAliveProvider(getKeepAliveProvider());\n-        updateConfigAlgorithms(sshClientConfig);\n-\n-        final SSHClient sshClient = new SSHClient(sshClientConfig);\n-\n-        // Create a Proxy if the config was specified, proxy will be null if type was NO_PROXY\n-        final Proxy proxy;\n-        final ProxyConfiguration proxyConfig = ProxyConfiguration.getConfiguration(ctx, createComponentProxyConfigSupplier(ctx));\n-        switch (proxyConfig.getProxyType()) {\n-            case HTTP:\n-            case SOCKS:\n-                proxy = proxyConfig.createProxy();\n-                break;\n-            default:\n-                proxy = null;\n-                break;\n-        }\n-\n-        // If a proxy was specified, configure the client to use a SocketFactory that creates Sockets using the proxy\n-        if (proxy != null) {\n-            sshClient.setSocketFactory(new SocketFactory() {\n-                @Override\n-                public Socket createSocket() {\n-                    return new Socket(proxy);\n-                }\n-\n-                @Override\n-                public Socket createSocket(String s, int i) {\n-                    return new Socket(proxy);\n-                }\n-\n-                @Override\n-                public Socket createSocket(String s, int i, InetAddress inetAddress, int i1) {\n-                    return new Socket(proxy);\n-                }\n-\n-                @Override\n-                public Socket createSocket(InetAddress inetAddress, int i) {\n-                    return new Socket(proxy);\n-                }\n-\n-                @Override\n-                public Socket createSocket(InetAddress inetAddress, int i, InetAddress inetAddress1, int i1) {\n-                    return new Socket(proxy);\n-                }\n-            });\n-        }\n-\n-        // If strict host key checking is false, add a HostKeyVerifier that always returns true\n-        final boolean strictHostKeyChecking = ctx.getProperty(STRICT_HOST_KEY_CHECKING).asBoolean();\n-        if (!strictHostKeyChecking) {\n-            sshClient.addHostKeyVerifier(new PromiscuousVerifier());\n-        }\n-\n-        // Load known hosts file if specified, otherwise load default\n-        final String hostKeyVal = ctx.getProperty(HOST_KEY_FILE).getValue();\n-        if (hostKeyVal != null) {\n-            sshClient.loadKnownHosts(new File(hostKeyVal));\n-            // Load default known_hosts file only when 'Strict Host Key Checking' property is enabled\n-        } else if (strictHostKeyChecking) {\n-            sshClient.loadKnownHosts();\n-        }\n-\n-        // Enable compression on the client if specified in properties\n-        final PropertyValue compressionValue = ctx.getProperty(FileTransfer.USE_COMPRESSION);\n-        if (compressionValue != null && \"true\".equalsIgnoreCase(compressionValue.getValue())) {\n-            sshClient.useCompression();\n-        }\n-\n-        // Configure connection timeout\n-        final int connectionTimeoutMillis = ctx.getProperty(FileTransfer.CONNECTION_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue();\n-        sshClient.setTimeout(connectionTimeoutMillis);\n-\n-        // Connect to the host and port\n-        final String hostname = ctx.getProperty(HOSTNAME).evaluateAttributeExpressions(flowFile).getValue();\n-        final int port = ctx.getProperty(PORT).evaluateAttributeExpressions(flowFile).asInteger();\n-        sshClient.connect(hostname, port);\n-\n-        // Setup authentication methods...\n-        final List<AuthMethod> authMethods = getAuthMethods(sshClient, flowFile);\n-\n-        // Authenticate...\n-        final String username = ctx.getProperty(USERNAME).evaluateAttributeExpressions(flowFile).getValue();\n-        sshClient.auth(username, authMethods);\n-\n-        // At this point we are connected and can create a new SFTPClient which means everything is good\n-        this.sshClient = sshClient;\n+        final Map<String, String> attributes = flowFile == null ? Collections.emptyMap() : flowFile.getAttributes();\n+        this.sshClient = SSH_CLIENT_PROVIDER.getClient(ctx, attributes);\n         this.sftpClient = sshClient.newSFTPClient();\n         this.closed = false;\n \n@@ -705,50 +573,12 @@ public class SFTPTransfer implements FileTransfer {\n             this.homeDir = \"\";\n             // For some combination of server configuration and user home directory, getHome() can fail with \"2: File not found\"\n             // Since  homeDir is only used tor SEND provenance event transit uri, this is harmless. Log and continue.\n-            logger.debug(\"Failed to retrieve {} home directory due to {}\", username, e.getMessage());\n+            logger.debug(\"Failed to retrieve home directory due to {}\", e.getMessage());\n         }\n \n         return sftpClient;\n     }\n \n-    void updateConfigAlgorithms(final Config config) {\n-        if (ctx.getProperty(CIPHERS_ALLOWED).isSet()) {\n-            Set<String> allowedCiphers = Arrays.stream(ctx.getProperty(CIPHERS_ALLOWED).evaluateAttributeExpressions().getValue().split(\",\"))\n-                    .map(String::trim)\n-                    .collect(Collectors.toSet());\n-            config.setCipherFactories(config.getCipherFactories().stream()\n-                    .filter(cipherNamed -> allowedCiphers.contains(cipherNamed.getName()))\n-                    .collect(Collectors.toList()));\n-        }\n-\n-        if (ctx.getProperty(KEY_ALGORITHMS_ALLOWED).isSet()) {\n-            Set<String> allowedKeyAlgorithms = Arrays.stream(ctx.getProperty(KEY_ALGORITHMS_ALLOWED).evaluateAttributeExpressions().getValue().split(\",\"))\n-                    .map(String::trim)\n-                    .collect(Collectors.toSet());\n-            config.setKeyAlgorithms(config.getKeyAlgorithms().stream()\n-                    .filter(keyAlgorithmNamed -> allowedKeyAlgorithms.contains(keyAlgorithmNamed.getName()))\n-                    .collect(Collectors.toList()));\n-        }\n-\n-        if (ctx.getProperty(KEY_EXCHANGE_ALGORITHMS_ALLOWED).isSet()) {\n-            Set<String> allowedKeyExchangeAlgorithms = Arrays.stream(ctx.getProperty(KEY_EXCHANGE_ALGORITHMS_ALLOWED).evaluateAttributeExpressions().getValue().split(\",\"))\n-                    .map(String::trim)\n-                    .collect(Collectors.toSet());\n-            config.setKeyExchangeFactories(config.getKeyExchangeFactories().stream()\n-                    .filter(keyExchangeNamed -> allowedKeyExchangeAlgorithms.contains(keyExchangeNamed.getName()))\n-                    .collect(Collectors.toList()));\n-        }\n-\n-        if (ctx.getProperty(MESSAGE_AUTHENTICATION_CODES_ALLOWED).isSet()) {\n-            Set<String> allowedMessageAuthenticationCodes = Arrays.stream(ctx.getProperty(MESSAGE_AUTHENTICATION_CODES_ALLOWED).evaluateAttributeExpressions().getValue().split(\",\"))\n-                    .map(String::trim)\n-                    .collect(Collectors.toSet());\n-            config.setMACFactories(config.getMACFactories().stream()\n-                    .filter(macNamed -> allowedMessageAuthenticationCodes.contains(macNamed.getName()))\n-                    .collect(Collectors.toList()));\n-        }\n-    }\n-\n     @Override\n     public String getHomeDirectory(final FlowFile flowFile) throws IOException {\n         getSFTPClient(flowFile);\n@@ -961,55 +791,4 @@ public class SFTPTransfer implements FileTransfer {\n         }\n         return number;\n     }\n-\n-    protected List<AuthMethod> getAuthMethods(final SSHClient client, final FlowFile flowFile) {\n-        final List<AuthMethod> authMethods = new ArrayList<>();\n-\n-        final String privateKeyPath = ctx.getProperty(PRIVATE_KEY_PATH).evaluateAttributeExpressions(flowFile).getValue();\n-        if (privateKeyPath != null) {\n-            final String privateKeyPassphrase = ctx.getProperty(PRIVATE_KEY_PASSPHRASE).evaluateAttributeExpressions(flowFile).getValue();\n-            final KeyProvider keyProvider = getKeyProvider(client, privateKeyPath, privateKeyPassphrase);\n-            final AuthMethod authPublicKey = new AuthPublickey(keyProvider);\n-            authMethods.add(authPublicKey);\n-        }\n-\n-        final String password = ctx.getProperty(FileTransfer.PASSWORD).evaluateAttributeExpressions(flowFile).getValue();\n-        if (password != null) {\n-            final AuthMethod authPassword = new AuthPassword(getPasswordFinder(password));\n-            authMethods.add(authPassword);\n-\n-            final PasswordResponseProvider passwordProvider = new PasswordResponseProvider(getPasswordFinder(password));\n-            final AuthMethod authKeyboardInteractive = new AuthKeyboardInteractive(passwordProvider);\n-            authMethods.add(authKeyboardInteractive);\n-        }\n-\n-        if (logger.isDebugEnabled()) {\n-            final List<String> methods = authMethods.stream().map(AuthMethod::getName).collect(Collectors.toList());\n-            logger.debug(\"Authentication Methods Configured {}\", methods);\n-        }\n-        return authMethods;\n-    }\n-\n-    private KeyProvider getKeyProvider(final SSHClient client, final String privateKeyLocation, final String privateKeyPassphrase) {\n-        final KeyFormat keyFormat = getKeyFormat(privateKeyLocation);\n-        logger.debug(\"Loading Private Key File [{}] Format [{}]\", privateKeyLocation, keyFormat);\n-        try {\n-            return privateKeyPassphrase == null ? client.loadKeys(privateKeyLocation) : client.loadKeys(privateKeyLocation, privateKeyPassphrase);\n-        } catch (final IOException e) {\n-            throw new ProcessException(String.format(\"Loading Private Key File [%s] Format [%s] Failed\", privateKeyLocation, keyFormat), e);\n-        }\n-    }\n-\n-    private KeyFormat getKeyFormat(final String privateKeyLocation) {\n-        try {\n-            final File privateKeyFile = new File(privateKeyLocation);\n-            return KeyProviderUtil.detectKeyFileFormat(privateKeyFile);\n-        } catch (final IOException e) {\n-            throw new ProcessException(String.format(\"Reading Private Key File [%s] Format Failed\", privateKeyLocation), e);\n-        }\n-    }\n-\n-    private PasswordFinder getPasswordFinder(final String password) {\n-        return PasswordUtils.createOneOff(password.toCharArray());\n-    }\n }\n",
  "files": 2,
  "linesAdd": 11,
  "linesRem": 233,
  "failing_tests": [],
  "nb_test": 0,
  "nb_failure": 0,
  "nb_error": 0,
  "nb_skipped": 0
}